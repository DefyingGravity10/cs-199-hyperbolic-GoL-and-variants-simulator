// Generated by CoffeeScript 2.7.0
(function () {
  //Operations on 3x3 matrices
  // Matrices stored as arrays, row by row
  var add,
    addScaledInplace,
    amplitude,
    approxEq,
    approxEqv,
    cleanupHyperbolicMoveMatrix,
    copy,
    eye,
    hrot,
    hyperbolicInv,
    inv,
    mul,
    mulv,
    rot,
    rotationMatrix,
    set,
    smul,
    translationMatrix,
    transpose,
    zero;

  exports.eye = eye = function () {
    return [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
  };

  exports.zero = zero = function () {
    return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
  };

  exports.set = set = function (m, i, j, v) {
    m[i * 3 + j] = v;
    return m;
  };

  exports.rot = rot = function (i, j, angle) {
    var c, m, s;
    m = eye();
    s = Math.sin(angle);
    c = Math.cos(angle);
    set(m, i, i, c);
    set(m, i, j, -s);
    set(m, j, i, s);
    set(m, j, j, c);
    return m;
  };

  exports.hrot = hrot = function (i, j, sinhD) {
    var c, m, s;
    m = eye();
    s = sinhD;
    c = Math.sqrt(sinhD * sinhD + 1);
    set(m, i, i, c);
    set(m, i, j, s);
    set(m, j, i, s);
    set(m, j, j, c);
    return m;
  };

  exports.mul = mul = function (m1, m2) {
    var i, j, k, l, m, o, p, s;
    m = zero();
    for (i = l = 0; l < 3; i = ++l) {
      for (j = o = 0; o < 3; j = ++o) {
        s = 0.0;
        for (k = p = 0; p < 3; k = ++p) {
          s += m1[i * 3 + k] * m2[k * 3 + j];
        }
        m[i * 3 + j] = s;
      }
    }
    return m;
  };

  exports.approxEq = approxEq = function (m1, m2, eps = 1e-6) {
    var d, i, l;
    d = 0.0;
    for (i = l = 0; l < 9; i = ++l) {
      d += Math.abs(m1[i] - m2[i]);
    }
    return d < eps;
  };

  exports.copy = copy = function (m) {
    return m.slice(0);
  };

  exports.mulv = mulv = function (m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2],
    ];
  };

  exports.approxEqv = approxEqv = function (v1, v2, eps = 1e-6) {
    var d, i, l;
    d = 0.0;
    for (i = l = 0; l < 3; i = ++l) {
      d += Math.abs(v1[i] - v2[i]);
    }
    return d < eps;
  };

  /*
   * m: matrix( [m0, m1, m2], [m3,m4,m5], [m6,m7,m8] );
   * ratsimp(invert(m)*determinant(m));
   * determinant(
   */
  exports.inv = inv = function (m) {
    var iD;
    //Calculated with maxima
    iD =
      1.0 /
      (m[0] * (m[4] * m[8] - m[5] * m[7]) -
        m[1] * (m[3] * m[8] - m[5] * m[6]) +
        m[2] * (m[3] * m[7] - m[4] * m[6]));
    return [
      (m[4] * m[8] - m[5] * m[7]) * iD,
      (m[2] * m[7] - m[1] * m[8]) * iD,
      (m[1] * m[5] - m[2] * m[4]) * iD,
      (m[5] * m[6] - m[3] * m[8]) * iD,
      (m[0] * m[8] - m[2] * m[6]) * iD,
      (m[2] * m[3] - m[0] * m[5]) * iD,
      (m[3] * m[7] - m[4] * m[6]) * iD,
      (m[1] * m[6] - m[0] * m[7]) * iD,
      (m[0] * m[4] - m[1] * m[3]) * iD,
    ];
  };

  exports.smul = smul = function (k, m) {
    var l, len, mi, results;
    results = [];
    for (l = 0, len = m.length; l < len; l++) {
      mi = m[l];
      results.push(mi * k);
    }
    return results;
  };

  exports.add = add = function (m1, m2) {
    var i, l, results;
    results = [];
    for (i = l = 0; l < 9; i = ++l) {
      results.push(m1[i] + m2[i]);
    }
    return results;
  };

  exports.addScaledInplace = addScaledInplace = function (m, m1, k) {
    var i, l, ref;
    for (
      i = l = 0, ref = m.length;
      0 <= ref ? l < ref : l > ref;
      i = 0 <= ref ? ++l : --l
    ) {
      m[i] += m1[i] * k;
    }
    return m;
  };

  exports.transpose = transpose = function (m) {
    return [m[0], m[3], m[6], m[1], m[4], m[7], m[2], m[5], m[8]];
  };

  exports.hyperbolicInv = hyperbolicInv = function (m) {
    //x' S x = 1, S = diag (-1, -1, 1)
    //x' M' S M x = 1
    //M' S M = S
    //M^-1 = SM'S
    return [m[0], m[3], -m[6], m[1], m[4], -m[7], -m[2], -m[5], m[8]];
  };

  exports.cleanupHyperbolicMoveMatrix = cleanupHyperbolicMoveMatrix = function (
    m
  ) {
    return smul(0.5, add(m, inv(hyperbolicInv(m))));
  };

  exports.translationMatrix = translationMatrix = function (dx, dy) {
    var dt, k, r2, xxk, xyk, yyk;
    //Formulae obtained with Maxima,
    // as combination of (inverse rotate) * (shift by x) * (rotate)
    // distance is acosh( dx^2 + dy^2 + 1 )
    r2 = dx * dx + dy * dy;
    dt = Math.sqrt(r2 + 1);
    k = r2 < 1e-6 ? 0.5 : (dt - 1) / r2;
    xxk = dx * dx * k;
    xyk = dx * dy * k;
    yyk = dy * dy * k;
    return [xxk + 1, xyk, dx, xyk, yyk + 1, dy, dx, dy, dt];
  };

  exports.rotationMatrix = rotationMatrix = function (angle) {
    var c, s;
    s = Math.sin(angle);
    c = Math.cos(angle);
    return [c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0];
  };

  exports.amplitude = amplitude = function (m) {
    var mi;
    return Math.max(
      ...(function () {
        var l, len, results;
        results = [];
        for (l = 0, len = m.length; l < len; l++) {
          mi = m[l];
          results.push(Math.abs(mi));
        }
        return results;
      })()
    );
  };

  //Decompose hyperbolic matrix to translation and rotation
  // returns 3 values: rotation angle, dx, dy
  // dx and dy are parameters of the translationMatrix
  exports.hyperbolicDecompose = function (m) {
    var R, T, cos, dx, dy, sin, t;
    //first, detect translation, look, how far it translates origin
    [dx, dy, t] = mulv(m, [0, 0, 1]);
    //multiply out the translation
    T = translationMatrix(-dx, -dy);
    R = mul(T, m);
    //now R shoulw be purely rotation matrix
    //TODO validate this?
    cos = (R[0] + R[4]) * 0.5;
    sin = (R[1] - R[3]) * 0.5;
    return [Math.atan2(sin, cos), dx, dy];
  };

  /*  array of matrix powers, from 0th to (n-1)th
   */
  exports.powers = function (matrix, n) {
    var i, l, m_n, pows, ref;
    //current power
    m_n = eye();
    pows = [m_n];
    for (
      i = l = 1, ref = n;
      1 <= ref ? l < ref : l > ref;
      i = 1 <= ref ? ++l : --l
    ) {
      m_n = mul(matrix, m_n);
      pows.push(m_n);
    }
    return pows;
  };
}).call(this);
