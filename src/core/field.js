// Generated by CoffeeScript 2.7.0
(function () {
  var ChainMap, extractClusterAt, importFieldTo, newNode, unity;

  ({ unity, newNode } = require("./vondyck_chain.js"));

  ({ ChainMap } = require("./chain_map.js"));

  //High-level utils for working with hyperbolic cellular fields
  exports.extractClusterAt = extractClusterAt = function (cells, tiling, chain) {
    var c, cluster, i, len, neighbor, ref, stack;
    //use cycle instead of recursion in order to avoid possible stack overflow.
    //Clusters may be big.
    stack = [chain];
    cluster = [];
    while (stack.length > 0) {
      c = stack.pop();
      if (cells.get(c) === null) {
        continue;
      }
      cells.remove(c);
      cluster.push(c);
      ref = tiling.moore(c);
      for (i = 0, len = ref.length; i < len; i++) {
        neighbor = ref[i];
        if (cells.get(neighbor) !== null) {
          stack.push(neighbor);
        }
      }
    }
    return cluster;
  };

  exports.allClusters = function (cells, tiling) {
    var cellsCopy, clusters;
    cellsCopy = cells.copy();
    clusters = [];
    cells.forItems(function (chain, value) {
      if (cellsCopy.get(chain) !== null) {
        return clusters.push(extractClusterAt(cellsCopy, tiling, chain));
      }
    });
    return clusters;
  };

  //Generate JS object from this field.
  // object tries to efectively store states of the field cells in the tree.
  // Position of echa cell is represented by chain.
  // Chains can be long; for nearby chains, their tails are the same.
  // Storing chains in list would cause duplication of repeating tails.

  // Object structure:
  // {
  //   g: 'a' or 'b', name of the group generator. Not present in root!
  //   p: integer, power of the generator. Not present in root!
  //   [v:] value of the cell. Optional.
  //   [cs]: [children] array of child trees
  // }
  exports.exportField = function (cells) {
    var chain2treeNode, putChain, root;
    root = {};
    chain2treeNode = new ChainMap();
    chain2treeNode.put(unity, root);
    putChain = function (chain) {
      //returns tree node for that chain
      var node, parentNode;
      node = chain2treeNode.get(chain);
      if (node === null) {
        parentNode = putChain(chain.t);
        node = {};
        node[chain.letter] = chain.p;
        if (parentNode.cs != null) {
          parentNode.cs.push(node);
        } else {
          parentNode.cs = [node];
        }
        chain2treeNode.put(chain, node);
      }
      return node;
    };
    cells.forItems(function (chain, value) {
      return (putChain(chain).v = value);
    });
    return root;
  };

  exports.importFieldTo = importFieldTo = function (fieldData, callback) {
    var putNode;
    putNode = function (rootChain, rootNode) {
      var childNode, i, len, ref;
      if (rootNode.v != null) {
        //node is a cell that stores some value?
        callback(rootChain, rootNode.v);
      }
      if (rootNode.cs != null) {
        ref = rootNode.cs;
        for (i = 0, len = ref.length; i < len; i++) {
          childNode = ref[i];
          if (childNode.a != null) {
            putNode(newNode("a", childNode.a, rootChain), childNode);
          } else if (childNode.b != null) {
            putNode(newNode("b", childNode.b, rootChain), childNode);
          } else {
            throw new Error("Node has neither A nor B generator");
          }
        }
      }
    };
    return putNode(unity, fieldData);
  };

  exports.importField = function (fieldData, cells = new ChainMap(), preprocess) {
    importFieldTo(fieldData, function (chain, value) {
      if (preprocess != null) {
        chain = preprocess(chain);
      }
      return cells.put(chain, value);
    });
    return cells;
  };

  //Generate random value in range from 1 to nStates-1
  exports.randomStateGenerator = function (nStates) {
    return function () {
      return (Math.floor(Math.random() * (nStates - 1)) | 0) + 1;
    };
  };

  exports.randomFill = function (field, density, center, r, tiling, randomState) {
    var cell, i, len, ref;
    if (density < 0 || density > 1.0) {
      throw new Error("Density must be in [0;1]");
    }
    //by default, fill with ones.
    randomState =
      randomState != null
        ? randomState
        : function () {
            return 1;
          };
    ref = tiling.farNeighborhood(center, r);
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      if (Math.random() < density) {
        field.put(cell, randomState());
      }
    }
  };

  //Fill randomly, visiting numCells cells around the given center.
  exports.randomFillFixedNum = function (field, density, center, numCells, tiling, randomState) {
    var visited;
    if (density < 0 || density > 1.0) {
      throw new Error("Density must be in [0;1]");
    }
    //by default, fill with ones.
    randomState =
      randomState != null
        ? randomState
        : function () {
            return 1;
          };
    visited = 0;
    tiling.forFarNeighborhood(center, function (cell, _) {
      if (visited >= numCells) {
        //Time to stop iteration?
        return false;
      }
      if (Math.random() < density) {
        field.put(cell, randomState());
      }
      visited += 1;
      //Continue
      return true;
    });
  };

  exports.stringifyFieldData = function (data) {
    var doStringify, parts;
    parts = [];
    doStringify = function (data) {
      var child, gen, i, len, pow, ref, results;
      if (data.v != null) {
        parts.push("|" + data.v);
      }
      if (data.cs != null) {
        ref = data.cs;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          parts.push("(");
          if (child.a != null) {
            gen = "a";
            pow = child.a;
          } else if (child.b != null) {
            gen = "b";
            pow = child.b;
          } else {
            //parts.push "b#{child.b}"
            throw new Error("bad data, neither a nor b");
          }
          if (pow < 0) {
            gen = gen.toUpperCase();
            pow = -pow;
          }
          parts.push(gen);
          if (pow !== 1) {
            parts.push(`${pow}`);
          }
          doStringify(child);
          results.push(parts.push(")"));
        }
        return results;
      }
    };
    doStringify(data);
    return parts.join("");
  };

  //Parse what stringifyFieldData returns.
  // Produce object, suitable for importField
  exports.parseFieldData = function (text) {
    var allRes, awaitChar, integer, parseChildSpec, parseValueSpec, pos, skipSpaces;
    integer = function (text, pos) {
      var c, getResult, sign, value;
      //console.log "parsing from #{pos}: '#{text}'"
      sign = 1;
      value = "";
      getResult = function () {
        var v;
        if (value === "") {
          return null;
        } else {
          v = sign * parseInt(value, 10);
          //console.log "parsed int: #{v}"
          return [v, pos];
        }
      };
      while (true) {
        if (pos >= text.length) {
          return getResult();
        }
        c = text[pos];
        if (c === "-") {
          sign = -sign;
        } else if (c >= "0" && c <= "9") {
          value += c;
        } else {
          return getResult();
        }
        pos += 1;
      }
    };
    skipSpaces = function (text, pos) {
      var ref;
      while (
        pos < text.length &&
        ((ref = text[pos]) === " " || ref === "\t" || ref === "\r" || ref === "\n")
      ) {
        pos += 1;
      }
      return pos;
    };
    awaitChar = function (char, text, pos) {
      var c;
      pos = skipSpaces(text, pos);
      if (pos >= text.length) {
        return null;
      }
      c = text[pos];
      pos += 1;
      if (c !== char) {
        return null;
      }
      return pos;
    };
    parseChildSpec = function (text, pos) {
      var gen, genLower, power, powerRes, powerSign, value, valueRes;
      //parse
      pos = awaitChar("(", text, pos);
      if (pos === null) {
        return null;
      }
      //parse generator name...
      pos = skipSpaces(text, pos);
      if (pos >= text.length) {
        return null;
      }
      gen = text[pos];
      pos += 1;
      if (gen !== "a" && gen !== "b" && gen !== "A" && gen !== "B") {
        return null;
      }
      genLower = gen.toLowerCase();
      powerSign = genLower === gen ? 1 : -1;
      gen = genLower;

      //parse generaotr power
      pos = skipSpaces(text, pos);
      powerRes = integer(text, pos);
      if (powerRes === null) {
        power = 1;
      } else {
        [power, pos] = powerRes;
      }
      power *= powerSign;
      //parse cell state and children
      pos = skipSpaces(text, pos);
      valueRes = parseValueSpec(text, pos);
      if (valueRes === null) {
        return null;
      }
      [value, pos] = valueRes;

      //store previously parsed generator and power
      value[gen] = power;
      //console.log "Value updated with generator data, waiting for ) from #{pos}, '#{text.substring(pos)}'"
      pos = skipSpaces(text, pos);
      pos = awaitChar(")", text, pos);
      if (pos === null) {
        return null;
      }
      //ok, parsed child fine!
      //console.log "parsed child OK"
      return [value, pos];
    };
    parseValueSpec = function (text, pos) {
      var childRes, children, intResult, pos1, value;
      value = {};
      pos = skipSpaces(text, pos);
      pos1 = awaitChar("|", text, pos);
      if (pos1 !== null) {
        //has value
        pos = pos1;
        intResult = integer(text, pos);
        if (intResult !== null) {
          [value.v, pos] = intResult;
        }
      }
      //parse children
      children = [];
      //console.log "parsing children from from #{pos}, '#{text.substring(pos)}'"
      while (true) {
        childRes = parseChildSpec(text, pos);
        if (childRes === null) {
          //console.log "no more children..."
          break;
        }
        children.push(childRes[0]);
        pos = childRes[1];
      }
      //console.log "parsed #{children.length} children"
      if (children.length > 0) {
        value.cs = children;
      }
      return [value, pos];
    };
    //finally, parse all
    allRes = parseValueSpec(text, 0);
    if (allRes === null) {
      throw new Error("Faield to parse!");
    }
    pos = allRes[1];
    pos = skipSpaces(text, pos);
    if (pos !== text.length) {
      throw new Error("garbage after end");
    }
    return allRes[0];
  };

  /*        
"""
exports.parseFieldData1 = (data) ->
  #data format (separators not included) is:
 *
 * text ::= value_spec
 * value_spec ::= [value]? ( '(' child_spec ')' )*
 * value ::= integer
 * child_spec ::= generator power value_spec
 * generator ::= a | b
 * power ::= integer
 *
 *

  #parser returns either null or pair:
 *  (parse result, next position)
 *
 * optional combinator
 * parse result is value of the inner parser or null
 * always succeeds
 *
  optional = (parser) -> (text, start) ->
    parsed = parser(text, start)
    if parsed is null
      [null, start]
    else
      parsed

  literal = (lit) -> (text, pos) ->
    for lit_i, i in lit
      if pos+i >= text.length
        return null
      if text[pos+i] isnt lit_i
        return null
    return [lit, pos+lit.length]

  oneOf = (parsers...) -> (text, pos) ->
    for p in parsers
      res = p(text,pos)
      return res if res isnt null
    return null

  word = (allowedChars) ->
    charSet = {}
    for c in allowedChars
      charSet[c] = true
    return (text, start) ->
      parseResult = ""
      pos = start
      while pos < text.length
        c = text[pos]
        if charSet.hasOwnProperty c
          parseResult += c
          pos += 1
        else
          break
      if parseResult is ""
        null
      else

  seq = (parsers) -> (text, pos) ->
    results = []
    for p in parsers
      r = p(text, pos)
      if r isnt null
        results.push r
        pos = r[1]
      else
        return null
    return [results, pos]

  map = (parser, func) -> (text, pos) ->
    r = parser(text, pos)
    return null if r is null
    return [func(r[0]), r[1]]

  integer = seq( optional(literal('-')), word('123456789')
  integer = map( parseInteger, [sign, digits]->
    parseInt((sign or '')+digits, 10) )

  parseInteger = (text, start) ->
    hasSign = false
    """
 */
}).call(this);
