// Generated by CoffeeScript 2.7.0
(function () {
  var addInplace, amplitude, combine2, scaleInplace;

  combine2 = function (v1, k1, v2, k2) {
    var i, l, ref, results;
    results = [];
    for (i = l = 0, ref = v1.length; l < ref; i = l += 1) {
      results.push(v1[i] * k1 + v2[i] * k2);
    }
    return results;
  };

  scaleInplace = function (v, k) {
    var i, l, ref;
    for (i = l = 0, ref = v.length; l < ref; i = l += 1) {
      v[i] *= k;
    }
    return v;
  };

  addInplace = function (v1, v2) {
    var i, l, len, v2i;
    for (i = l = 0, len = v2.length; l < len; i = ++l) {
      v2i = v2[i];
      v1[i] += v2[i];
    }
    return v1;
  };

  amplitude = function (x) {
    var xi;
    return Math.max(
      ...(function () {
        var l, len, results;
        results = [];
        for (l = 0, len = x.length; l < len; l++) {
          xi = x[l];
          results.push(Math.abs(xi));
        }
        return results;
      })()
    );
  };

  //optimal parameters for Rozenbrock optimiation
  exports.alpha = 2.05;

  exports.beta = 0.46;

  exports.gamma = 0.49;

  exports.fminsearch = function (func, x0, step, tol = 1e-6, maxiter = 10000) {
    var alpha,
      beta,
      evaluations,
      f0,
      fe,
      fg,
      fh,
      fi,
      findCenter,
      fr,
      fs,
      gamma,
      i,
      iter,
      l,
      m,
      makeAnswerOK,
      n,
      poly,
      polySize,
      ref,
      ref1,
      rval,
      sortPoints,
      withValue,
      x,
      xc,
      xe,
      xh,
      xi,
      xr,
      xs;
    alpha = exports.alpha;
    beta = exports.beta;
    gamma = exports.gamma;
    n = x0.length;
    //generate initial polygon
    poly = (function () {
      var l, ref, results;
      results = [];
      for (i = l = 0, ref = n; l <= ref; i = l += 1) {
        results.push(x0.slice(0));
      }
      return results;
    })();
    for (i = l = 1, ref = n; l <= ref; i = l += 1) {
      poly[i][i - 1] += step;
    }
    evaluations = n + 1;
    findCenter = function () {
      var m, ref1, xc;
      xc = withValue[0][0].slice(0);
      for (i = m = 1, ref1 = n - 1; m <= ref1; i = m += 1) {
        addInplace(xc, withValue[i][0]);
      }
      scaleInplace(xc, 1.0 / n);
      return xc;
    };
    polySize = function () {
      var j, len, m, maxima, minima, o, ref1, xi, xij;
      minima = withValue[0][0].slice(0);
      maxima = withValue[0][0].slice(0);
      for (i = m = 1, ref1 = withValue.length; m < ref1; i = m += 1) {
        xi = withValue[i][0];
        for (j = o = 0, len = xi.length; o < len; j = ++o) {
          xij = xi[j];
          if (xij < minima[j]) {
            minima[j] = xij;
          }
          if (xij > maxima[j]) {
            maxima[j] = xij;
          }
        }
      }
      return Math.max(
        ...(function () {
          var p, ref2, results;
          results = [];
          for (i = p = 0, ref2 = n; p < ref2; i = p += 1) {
            results.push(maxima[i] - minima[i]);
          }
          return results;
        })()
      );
    };
    makeAnswerOK = function () {
      var rval;
      return (rval = {
        reached: true,
        x: withValue[0][0],
        f: withValue[0][1],
        steps: iter,
        evaluations: evaluations
      });
    };
    withValue = (function () {
      var len, m, results;
      results = [];
      for (m = 0, len = poly.length; m < len; m++) {
        x = poly[m];
        results.push([x, func(x)]);
      }
      return results;
    })();
    //sort by function value
    sortPoints = function () {
      return withValue.sort(function (a, b) {
        return a[1] - b[1];
      });
    };
    iter = 0;
    while (iter < maxiter) {
      iter += 1;
      sortPoints();

      //worst is last

      //find center of all points except the last (worst) one.
      xc = findCenter();
      //Best, worst and first-before-worst values.
      f0 = withValue[0][1];
      fg = withValue[n - 1][1];
      [xh, fh] = withValue[n];
      //console.log "I=#{iter}\tf0=#{f0}\tfg=#{fg}\tfh=#{fh}"

      //reflect
      //xr = xc-(xh-xc) = 2xc - xh
      xr = combine2(xc, 2.0, xh, -1.0);
      fr = func(xr);
      evaluations += 1;
      if (fr < f0) {
        //extend
        // xe = xc+ (xr-xc)*alpha = xr*alpha + xc*(1-alpha)
        xe = combine2(xr, alpha, xc, 1 - alpha);
        fe = func(xe);
        evaluations += 1;
        if (fe < fr) {
          //use fe
          withValue[n] = [xe, fe];
        } else {
          //use fr
          withValue[n] = [xr, fr];
        }
      } else if (fr < fg) {
        //use xr
        withValue[n] = [xr, fr];
      } else {
        // This is present in the original decription of the method, but it makes result even slightly worser!
        //if fr < fh
        //  #swap xr, xg
        //  [[xr, fr], withValue[n-1]] = [withValue[n-1], [xr, fr]]
        //  # my own invertion - makes worser.
        //  #xc = findCenter()

        //now fr >= fh
        //shrink
        //xs = xc+ (xr-xc)*beta
        xs = combine2(xh, beta, xc, 1 - beta);
        fs = func(xs);
        evaluations += 1;
        if (fs < fh) {
          //use shrink
          withValue[n] = [xs, fs];
          if (polySize() < tol) {
            return makeAnswerOK();
          }
        } else {
          //global shrink
          x0 = withValue[0][0];
          //check exit
          if (polySize() < tol) {
            return makeAnswerOK();
          }
          //global shrink
          for (i = m = 1, ref1 = n; 1 <= ref1 ? m <= ref1 : m >= ref1; i = 1 <= ref1 ? ++m : --m) {
            xi = combine2(withValue[i][0], gamma, x0, 1 - gamma);
            fi = func(xi);
            withValue[i] = [xi, fi];
          }
          evaluations += n;
        }
      }
    }
    sortPoints();
    return (rval = {
      reached: false,
      x: withValue[0][0],
      f: withValue[0][1],
      steps: iter,
      evaluations: evaluations
    });
  };
}).call(this);
