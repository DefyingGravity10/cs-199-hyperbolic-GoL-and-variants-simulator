// Generated by CoffeeScript 2.7.0
(function () {
  var ChainMap, evaluateTotalisticAutomaton, neighborsSum, NeighborColorMap;

  ({ ChainMap } = require("./chain_map.js"));
  ({ NeighborColorMap } = require("./variant_util.js"));

  colorDict = new NeighborColorMap();

  exports.neighborsSum = neighborsSum = function (
    cells,
    tiling,
    plus = function (x, y) {
      // Unsure if this is correct since it is no longer consistent with the others
      if (y > 0) {
        return x + y;
      } else {
        return x + y;
      }
    },
    plusInitial = 0,
    variant
  ) {
    var sums;
    sums = new ChainMap();
    cells.forItems(function (cell, value) {
      var i, len, neighbor, ref;
      ref = tiling.moore(cell);

      // Logs used for checking
      // console.log(`CELL: ${cell} (state ${value})`);
      // console.log(`NEIGHBORS ${ref}`);

      for (i = 0, len = ref.length; i < len; i++) {
        neighbor = ref[i];

        // Log used for checking
        // console.log(`Neighbor: ${neighbor}`);
        if (variant === "immigration") {
          colorDict.updateNeighborColorCounts(neighbor, value);
        } else if (variant === "rainbow") {
          colorDict.addStateOfNeighbors(neighbor, cell, value);
        }
        sums.putAccumulate(neighbor, value, plus, plusInitial);
      }
      // Log used for checking
      // console.log(colorDict.getStatesOfNeighbors());

      //don't forget the cell itself! It must also present, with zero (initial) neighbor sum
      if (sums.get(cell) === null) {
        return sums.put(cell, plusInitial);
      }
    });
    return sums;
  };

  exports.evaluateTotalisticAutomaton = evaluateTotalisticAutomaton = function (
    cells,
    tiling,
    nextStateFunc,
    plus,
    plusInitial,
    variant,
    updatePolicy
  ) {
    var newCells, sums, randomValue;
    const probability = 0.5; // Fixed value

    newCells = new ChainMap();
    sums = neighborsSum(cells, tiling, plus, plusInitial, variant);
    sums.forItems(function (cell, neighSum) {
      var cellState, currentState, nextState, ref;
      cellState = (ref = cells.get(cell)) != null ? ref : 0;

      // Done to take note of the cell's current state
      currentState = cellState;
      // For the asynchronous variant
      // Check if the update policy is asynchronous AND if the cell will update for this generation
      randomValue = Math.random();
      if (updatePolicy === "asynchronous" && randomValue > probability && currentState !== 0) {
        // Ensure that the state will not change and only "put" cells if their state is not equal to zero
        return newCells.put(cell, currentState);
      }
      // Do this if the state of the cell is expected to change (if needed)
      if (cellState >= 1 && (variant === "immigration" || variant === "rainbow")) {
        // Note that each state is represented by a number.
        // Thus the computation for the next state can be affected.
        // So we also make it equivalent to 1.
        // Doing it inside the plus function does not work for some reason
        cellState = cellState / cellState;
      }
      nextState = nextStateFunc(cellState, neighSum);
      // Only "put" cells if nextState is not equal to zero
      if (nextState !== 0) {
        // For the colored variants. Only let the state change if the current state is 0
        // as the color only changes once the cell is "born again"
        if (currentState === 0) {
          if (variant === "immigration") {
            nextState = nextState * colorDict.determineHighestColorCount(cell);
          } else if (variant === "rainbow") {
            console.log(`New State of cell ${cell}: ${colorDict.computeNewState(cell)}`);
            nextState = nextState * colorDict.computeNewState(cell);
          }
        } else {
          nextState = nextState * currentState;
        }
        return newCells.put(cell, nextState);
      }
    });
    colorDict.emptyNeighborColorCounts();
    colorDict.emptyStatesOfNeighbors();
    return newCells;
  };
}).call(this);
