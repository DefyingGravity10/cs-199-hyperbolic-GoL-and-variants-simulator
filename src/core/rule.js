// Generated by CoffeeScript 2.7.0
(function() {
  var BaseFunc, BinaryTransitionFunc, DayNightTransitionFunc, GenericTransitionFunc, binaryTransitionFunc2GenericCode, dayNightBinaryTransitionFunc2GenericCode, isDayNightRule, parseIntChecked, parseTransitionFunction,
    indexOf = [].indexOf;

  ({parseIntChecked} = require("./utils.js"));

  BaseFunc = (function() {
    class BaseFunc {
      plus(x, y) {
        return x + y;
      }

      setGeneration(g) {}

      getType() {
        throw new Error("Function type undefined");
      }

      toGeneric() {
        throw new Error("Function type undefined");
      }

      evaluate() {
        throw new Error("Function type undefined");
      }

      changeGrid(n, m) {
        return this;
      }

    };

    BaseFunc.prototype.plusInitial = 0;

    return BaseFunc;

  }).call(this);

  
  // Generic TF is given by its code.
  // Code is a JS object with 3 fields:
  // states: N #integer
  // sum: (r, x) -> r'  #default is (x,y) -> x+y
  // sumInitial: value r0 #default is 0
  // next: (sum, value) -> value
  exports.GenericTransitionFunc = GenericTransitionFunc = class GenericTransitionFunc extends BaseFunc {
    constructor(code1) {
      super(BaseFunc);
      this.code = code1;
      this.generation = 0;
      this._parse();
    }

    toString() {
      return this.code;
    }

    isStable() {
      return this.evaluate(0, 0) === 0;
    }

    setGeneration(g) {
      return this.generation = g;
    }

    getType() {
      return "custom";
    }

    _parse() {
      var ref, ref1, tfObject;
      tfObject = eval('(' + this.code + ')');
      if (tfObject.states == null) {
        throw new Error("Numer of states not specified");
      }
      if (tfObject.next == null) {
        throw new Error("Transition function not specified");
      }
      this.numStates = tfObject.states;
      this.plus = (ref = tfObject.sum) != null ? ref : (function(x, y) {
        return x + y;
      });
      this.plusInitial = (ref1 = tfObject.sumInitial) != null ? ref1 : 0;
      this.evaluate = tfObject.next;
      if (this.numStates <= 1) {
        throw new Error("Number of states must be 2 or more");
      }
    }

    toGeneric() {
      return this;
    }

  };

  
  //DayNight functions are those, who transform empty field to filled and back.
  // They can be effectively simulated as a pair of 2 rules, applying one rule for even generations and another for odd.
  isDayNightRule = function(binaryFunc) {
    return binaryFunc.evaluate(0, 0) === 1 && binaryFunc.evaluate(1, binaryFunc.numNeighbors) === 0;
  };

  exports.DayNightTransitionFunc = DayNightTransitionFunc = (function() {
    class DayNightTransitionFunc extends BaseFunc {
      constructor(base) {
        super(BaseFunc);
        this.base = base;
        if (!isDayNightRule(this.base)) {
          throw new Error("base function is not flashing");
        }
        this.phase = 0;
      }

      toString() {
        return this.base.toString();
      }

      getType() {
        return "binary";
      }

      setGeneration(g) {
        return this.phase = g & 1;
      }

      isStable() {
        return this.base.evaluate(0, 0) === 1 && this.base.evaluate(1, this.base.numNeighbors) === 0;
      }

      evaluate(x, s) {
        if (this.phase) {
          return 1 - this.base.evaluate(x, s);
        } else {
          return this.base.evaluate(1 - x, this.base.numNeighbors - s);
        }
      }

      toGeneric() {
        return new GenericTransitionFunc(dayNightBinaryTransitionFunc2GenericCode(this));
      }

      changeGrid(n, m) {
        return new DayNightTransitionFunc(this.base.changeGrid(n, m));
      }

    };

    DayNightTransitionFunc.prototype.numStates = 2;

    return DayNightTransitionFunc;

  }).call(this);

  exports.BinaryTransitionFunc = BinaryTransitionFunc = (function() {
    class BinaryTransitionFunc extends BaseFunc {
      constructor(n1, m1, bornAt, stayAt) {
        var arr, s;
        super(BaseFunc);
        this.n = n1;
        this.m = m1;
        this.numNeighbors = this.n * (this.m - 2);
        this.table = (function() {
          var j, len, ref, results;
          ref = [bornAt, stayAt];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            arr = ref[j];
            results.push((function() {
              var k, ref1, results1;
              results1 = [];
              for (s = k = 0, ref1 = this.numNeighbors; k <= ref1; s = k += 1) {
                if (indexOf.call(arr, s) >= 0) {
                  results1.push(1);
                } else {
                  results1.push(0);
                }
              }
              return results1;
            }).call(this));
          }
          return results;
        }).call(this);
      }

      isStable() {
        return table[0][0] === 0;
      }

      plus(x, y) {
        return x + y;
      }

      getType() {
        return "binary";
      }

      evaluate(state, sum) {
        if (state !== 0 && state !== 1) {
          throw new Error(`Bad state: ${state}`);
        }
        if (sum < 0 || sum > this.numNeighbors) {
          throw new Error(`Bad sum: ${sum}`);
        }
        return this.table[state][sum];
      }

      toString() {
        return "B " + this._nonzeroIndices(this.table[0]).join(" ") + " S " + this._nonzeroIndices(this.table[1]).join(" ");
      }

      _nonzeroIndices(arr) {
        var i, j, len, results, x;
        results = [];
        for (i = j = 0, len = arr.length; j < len; i = ++j) {
          x = arr[i];
          if (x !== 0) {
            results.push(i);
          }
        }
        return results;
      }

      toGeneric() {
        return new GenericTransitionFunc(binaryTransitionFunc2GenericCode(this));
      }

      changeGrid(n, m) {
        //OK, that's dirty but easy
        return parseTransitionFunction(this.toString(), n, m, false);
      }

    };

    BinaryTransitionFunc.prototype.plusInitial = 0;

    BinaryTransitionFunc.prototype.numStates = 2;

    return BinaryTransitionFunc;

  }).call(this);

  
  // BxxxSxxx
  exports.parseTransitionFunction = parseTransitionFunction = function(str, n, m, allowDayNight = true) {
    var bArray, func, match, sArray, strings2array;
    match = str.match(/^\s*B([\d\s]+)S([\d\s]+)$/);
    if (match == null) {
      throw new Error(`Bad function string: ${str}`);
    }
    strings2array = function(s) {
      var j, len, part, ref, results;
      ref = s.split(' ');
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        part = ref[j];
        if (part) {
          results.push(parseIntChecked(part));
        }
      }
      return results;
    };
    bArray = strings2array(match[1]);
    sArray = strings2array(match[2]);
    func = new BinaryTransitionFunc(n, m, bArray, sArray);
    //If allowed, convert function to day/night rule
    if (allowDayNight && isDayNightRule(func)) {
      return new DayNightTransitionFunc(func);
    } else {
      return func;
    }
  };

  exports.binaryTransitionFunc2GenericCode = binaryTransitionFunc2GenericCode = function(binTf) {
    var code, conditionBorn, conditionStay, row2condition;
    row2condition = function(row) {
      var nextValue, sum;
      return ((function() {
        var j, len, results;
        results = [];
        for (sum = j = 0, len = row.length; j < len; sum = ++j) {
          nextValue = row[sum];
          if (nextValue) {
            results.push(`s===${sum}`);
          }
        }
        return results;
      })()).join(" || ");
    };
    conditionBorn = row2condition(binTf.table[0]);
    conditionStay = row2condition(binTf.table[1]);
    return code = [
      `//Automatically generated code for binary rule ${binTf}
{
    //number of states
    'states': 2,

    //Neighbors sum calculation is default. Code for reference.
    //'plus': function(s,x){ return s+x; },
    //'plusInitial': 0,
    
    //Transition function. Takes current state and sum, returns new state.
    //this.generation stores current generation number
    'next': function(x, s){
        if (x===1 && (${conditionStay})) return 1;
        if (x===0 && (${conditionBorn})) return 1;
        return 0;
     }
}`
    ];
  };

  exports.dayNightBinaryTransitionFunc2GenericCode = dayNightBinaryTransitionFunc2GenericCode = function(binTf) {
    var code, conditionBorn, conditionBornInv, conditionStay, conditionStayInv, row2condition, row2conditionInv;
    row2condition = function(row) {
      var nextValue, sum;
      return ((function() {
        var j, len, results;
        results = [];
        for (sum = j = 0, len = row.length; j < len; sum = ++j) {
          nextValue = row[sum];
          if (nextValue) {
            results.push(`s===${sum}`);
          }
        }
        return results;
      })()).join(" || ");
    };
    row2conditionInv = function(row) {
      var nextValue, sum;
      return ((function() {
        var j, len, results;
        results = [];
        for (sum = j = 0, len = row.length; j < len; sum = ++j) {
          nextValue = row[sum];
          if (nextValue) {
            results.push(`s===${binTf.base.numNeighbors - sum}`);
          }
        }
        return results;
      })()).join(" || ");
    };
    conditionBorn = row2condition(binTf.base.table[0]);
    conditionStay = row2condition(binTf.base.table[1]);
    conditionBornInv = row2conditionInv(binTf.base.table[0]);
    conditionStayInv = row2conditionInv(binTf.base.table[1]);
    return code = [
      `//Automatically generated code for population-inverting binary rule ${binTf}
{
    //number of states
    'states': 2,

    //Neighbors sum calculation is default. Code for reference.
    //'plus': function(s,x){ return s+x; },
    //'plusInitial': 0,
    
    //Transition function. Takes current state and sum, returns new state.
    'next': function(x, s){
        var phase = this.generation & 1;

        //The original rule ${binTf} inverts state of an empty field
        //To calculate it efficiently, we instead invert each odd generation, so that population never goes to infinity.
        
        
        if (phase === 0){
            //On even generations, invert output
            if (x===1 && (${conditionStay})) return 0;
            if (x===0 && (${conditionBorn})) return 0;
            return 1
        } else {
            //On odd generations, invert input state and nighbors sum
            if (x===0 && (${conditionStayInv})) return 1;
            if (x===1 && (${conditionBornInv})) return 1;
            return 0;
        }
     }
}`
    ];
  };

}).call(this);
