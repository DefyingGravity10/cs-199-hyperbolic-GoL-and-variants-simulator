// Generated by CoffeeScript 2.7.0
(function() {
  /* Implementation of values of von Dyck groups.
   *  Each value is a chain of powers of 2 generators: A and B
   *
   *  Example:
   *    x = a*b*a-1*b^2*a*b-3
   *
   *  vD groups have additional relations for generators:
   *   a^n === b^m === (ab)^k,
   *  however this implementation is agnostic about these details.
   *  They are implemented by the js_rewriter module.
   *
   *  (To this module actually implements free group of 2 generators...)
   *
   *  To facilitate chain appending/truncating, theyt are implemented as a functional data structure.
   *  Root element is `unity`, it represens identity element of the group.
   */
  var M, Node, NodeA, NodeB, chainEquals, newNode, nodeConstructors, reverseShortlexLess, showChain, truncateA, truncateB, unity;

  M = require("./matrix3.js");

  exports.Node = Node = class Node {
    hash() {
      var h;
      if ((h = this.h) !== null) {
        return h;
      } else {
        //seen here: http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
        h = this.t.hash();
        return this.h = (((h << 5) - h) + (this.letterCode << 7) + this.p) | 0;
      }
    }

    repr(generatorMatrices) {
      var m;
      if ((m = this.mtx) !== null) {
        return m;
      } else {
        return this.mtx = M.mul(this.t.repr(generatorMatrices), generatorMatrices.generatorPower(this.letter, this.p));
      }
    }

    len() {
      return this.l;
    }

    equals(c) {
      return chainEquals(this, c);
    }

    a(pow) {
      return new NodeA(pow, this);
    }

    b(pow) {
      return new NodeB(pow, this);
    }

    toString() {
      return showChain(this);
    }

    /* Convert chain to array of pairs: [letter, power], where letter is "a" or "b" and power is integer.
     * Top element of the chain becomes first element of the array
      */
    asStack() {
      var node, result;
      result = [];
      node = this;
      while (node !== unity) {
        result.push([node.letter, node.p]);
        node = node.t;
      }
      return result;
    }

    
      //Append elements from the array to the chain.
    // First element of the array becomes top element of the chain;
    // stack itself becomes empty
    appendStack(stack) {
      var chain, e, p;
      chain = this;
      while (stack.length > 0) {
        [e, p] = stack.pop();
        chain = newNode(e, p, chain);
      }
      return chain;
    }

  };

  exports.unity = unity = new Node();

  unity.l = 0;

  unity.h = 0;

  unity.mtx = M.eye();

  unity.repr = function(g) {
    return this.mtx; //jsut overload with a faster code.
  };

  exports.NodeA = NodeA = (function() {
    class NodeA extends Node {
      constructor(p1, t) {
        super(Node);
        this.p = p1;
        this.t = t;
        this.l = this.t === unity ? 1 : this.t.l + 1;
        this.h = null;
        this.mtx = null; //support for calculating matrix representations
      }

    };

    NodeA.prototype.letter = 'a';

    NodeA.prototype.letterCode = 0;

    return NodeA;

  }).call(this);

  exports.NodeB = NodeB = (function() {
    class NodeB extends Node {
      constructor(p1, t) {
        super(Node);
        this.p = p1;
        this.t = t;
        this.l = this.t === unity ? 1 : this.t.l + 1;
        this.h = null;
        this.mtx = null;
      }

    };

    NodeB.prototype.letter = 'b';

    NodeB.prototype.letterCode = 1;

    return NodeB;

  }).call(this);

  chainEquals = function(a, b) {
    while (true) {
      if (a === b) {
        return true;
      }
      if (a === unity || b === unity) {
        return false; //a is E and b is E, but not both
      }
      if ((a.letter !== b.letter) || (a.p !== b.p)) {
        return false;
      }
      a = a.t;
      b = b.t;
    }
  };

  showChain = function(node) {
    var letter, parts, power;
    if (node === unity) {
      return 'e';
    }
    parts = [];
    while (node !== unity) {
      letter = node.letter;
      power = node.p;
      if (power < 0) {
        letter = letter.toUpperCase();
        power = -power;
      }
      //Adding in reverse order!
      if (power !== 1) {
        parts.push(`^${power}`);
      }
      parts.push(letter);
      node = node.t;
    }
    return parts.reverse().join('');
  };

  //reverse of showChain
  exports.parseChain = function(s) {
    var letter, letterLow, match, power, prepend, ref, updPrepender;
    if (s === '' || s === 'e') {
      return unity;
    }
    prepend = function(tail) {
      return tail;
    };
    updPrepender = function(prepender, letter, power) {
      return function(tail) {
        return newNode(letter, power, prepender(tail));
      };
    };
    while (s) {
      match = s.match(/([aAbB])(?:\^(\d+))?/);
      if (!match) {
        throw new Error(`Bad syntax: ${s}`);
      }
      s = s.substr(match[0].length);
      letter = match[1];
      power = parseInt((ref = match[2]) != null ? ref : '1', 10);
      letterLow = letter.toLowerCase();
      if (letter !== letterLow) {
        power = -power;
      }
      prepend = updPrepender(prepend, letterLow, power);
    }
    return prepend(unity);
  };

  exports.truncateA = truncateA = function(chain) {
    while ((chain !== unity) && (chain.letter === "a")) {
      chain = chain.t;
    }
    return chain;
  };

  exports.truncateB = truncateB = function(chain) {
    while ((chain !== unity) && (chain.letter === "b")) {
      chain = chain.t;
    }
    return chain;
  };

  exports.nodeConstructors = nodeConstructors = {
    a: NodeA,
    b: NodeB
  };

  exports.newNode = newNode = function(letter, power, parent) {
    return new nodeConstructors[letter](power, parent);
  };

  /*
   * Reverse compare 2 chains by shortlex algorithm
   */
  exports.reverseShortlexLess = reverseShortlexLess = function(c1, c2) {
    if (c1 === unity) {
      return c2 !== unity;
    } else {
      //c1 not unity
      if (c2 === unity) {
        return false;
      } else {
        //neither is unity
        if (c1.l !== c2.l) {
          return c1.l < c2.l;
        }
        //both are equal length
        while (c1 !== unity) {
          if (c1.letter !== c2.letter) {
            return c1.letter < c2.letter;
          }
          if (c1.p !== c2.p) {
            return c1.p < c2.p;
          }
          //go upper
          c1 = c1.t;
          c2 = c2.t;
        }
        //exactly equal
        return false;
      }
    }
  };

}).call(this);
