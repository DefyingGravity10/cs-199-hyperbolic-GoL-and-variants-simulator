// Generated by CoffeeScript 2.7.0
(function () {
  "use strict";
  var Animator,
    E,
    M,
    decomposeToTranslations,
    flipSetTimeout,
    formatString,
    interpolateHyperbolic,
    pad,
    parseIntChecked;

  //Hyperbolic computations core
  M = require("../core/matrix3.js");

  ({ decomposeToTranslations } = require("../core/decompose_to_translations.js"));

  //Misc utilities
  ({ E, flipSetTimeout } = require("./htmlutil.js"));

  ({ formatString, pad, parseIntChecked } = require("../core/utils.js"));

  interpolateHyperbolic = function (T) {
    var Tdist, Tdx, Tdy, Tr, Tr2, Trot, dirX, dirY;
    [Trot, Tdx, Tdy] = M.hyperbolicDecompose(T);
    //Real distance translated is acosh( sqrt(1+dx^2+dy^2))
    Tr2 = Tdx ** 2 + Tdy ** 2;
    Tdist = Math.acosh(Math.sqrt(Tr2 + 1.0));
    Tr = Math.sqrt(Tr2);
    if (Tr < 1e-6) {
      dirX = 0.0;
      dirY = 0.0;
    } else {
      dirX = Tdx / Tr;
      dirY = Tdy / Tr;
    }
    return function (p) {
      var dist, dx, dy, r, rot;
      rot = Trot * p;
      dist = Tdist * p;
      r = Math.sqrt(Math.cosh(dist) ** 2 - 1.0);
      dx = r * dirX;
      dy = r * dirY;
      return M.mul(M.translationMatrix(dx, dy), M.rotationMatrix(rot));
    };
  };

  exports.Animator = Animator = class Animator {
    constructor(application) {
      this.application = application;
      this.oldSize = null;
      this.uploadWorker = null;
      this.busy = false;
      this.reset();
    }

    assertNotBusy() {
      if (this.busy) {
        throw new Error("Animator is busy");
      }
    }

    reset() {
      if (this.busy) {
        this.cancelWork();
      }
      this.startChain = null;
      this.startOffset = null;
      this.endChain = null;
      this.endOffset = null;
      return this._updateButtons();
    }

    _updateButtons() {
      E("animate-view-start").disabled = this.startChain === null;
      E("animate-view-end").disabled = this.endChain === null;
      E("btn-upload-animation").disabled = this.startChain === null || this.endChain === null;
      E("btn-animate-cancel").style.display = this.busy ? "" : "none";
      E("btn-upload-animation").style.display = !this.busy ? "" : "none";
      return (E("btn-animate-derotate").disabled = !(
        this.startChain != null && this.endChain != null
      ));
    }

    setStart(observer) {
      this.assertNotBusy();
      this.startChain = observer.getViewCenter();
      this.startOffset = observer.getViewOffsetMatrix();
      return this._updateButtons();
    }

    setEnd(observer) {
      this.assertNotBusy();
      this.endChain = observer.getViewCenter();
      this.endOffset = observer.getViewOffsetMatrix();
      return this._updateButtons();
    }

    viewStart(observer) {
      this.assertNotBusy();
      return observer.navigateTo(this.startChain, this.startOffset);
    }

    viewEnd(observer) {
      this.assertNotBusy();
      return observer.navigateTo(this.endChain, this.endOffset);
    }

    derotate() {
      var R, _, c, dx, dy, r, s, t1, t2;
      console.log("offset matrix:");
      console.dir(this.offsetMatrix());
      [t1, t2] = decomposeToTranslations(this.offsetMatrix());
      if (t1 === null) {
        alert("Derotation not possible");
        return;
      }
      //@endOffset * Mdelta * @startOffset^-1 = t1^-1 * t2 * t1
      this.endOffset = M.mul(t1, this.endOffset);
      this.startOffset = M.mul(t1, this.startOffset);
      //and now apply similarity rotation to both of the start and end points so that t2 is strictly vertical
      [dx, dy, _] = M.mulv(t2, [0, 0, 1]);
      r = Math.sqrt(dx ** 2 + dy ** 2);
      if (r > 1e-6) {
        s = dy / r;
        c = dx / r;
        R = [c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0];
        R = M.mul(R, M.rotationMatrix(-Math.PI / 2));
        this.endOffset = M.mul(R, this.endOffset);
        this.startOffset = M.mul(R, this.startOffset);
      }
      return alert("Start and end point adjusted.");
    }

    _setCanvasSize() {
      var canvas, size;
      size = parseIntChecked(E("animate-size").value);
      if (size <= 0 || size >= 65536) {
        throw new Error(`Size ${size} is inappropriate`);
      }
      this.application.setCanvasResize(true);
      canvas = this.application.getCanvas();
      this.oldSize = [canvas.width, canvas.height];
      return (canvas.width = canvas.height = size);
    }

    _restoreCanvasSize() {
      var canvas;
      if (!this.oldSize) {
        throw new Error("restore withou set");
      }
      canvas = this.application.getCanvas();
      [canvas.width, canvas.height] = this.oldSize;
      this.oldSize = null;
      this.application.setCanvasResize(false);
      return this.application.redraw();
    }

    _beginWork() {
      this.busy = true;
      this._setCanvasSize();
      this._updateButtons();
      return console.log("Started animation");
    }

    _endWork() {
      this._restoreCanvasSize();
      console.log("End animation");
      this.busy = false;
      return this._updateButtons();
    }

    cancelWork() {
      if (!this.busy) {
        return;
      }
      if (this.uploadWorker) {
        clearTimeout(this.uploadWorker);
      }
      this.uploadWorker = null;
      return this._endWork();
    }

    //matrix between first and last points
    offsetMatrix() {
      var Mdelta, T, app, inv, tiling;
      //global (surreally big) view matrix is:

      // Moffset * M(chain)

      // where Moffset is view offset, and M(chain) is transformation matrix of the chain.
      // We need to find matrix T such that

      //  T * MoffsetStart * M(chainStart) = MoffsetEnd * M(chainEnd)

      // Solvign this, get:
      // T = MoffsetEnd * (M(chainEnd) * M(chainStart)^-1) * MoffsetStart^-1

      // T = MoffsetEnd * M(chainEnd + invChain(chainStart) * MoffsetStart^-1
      tiling = this.application.tiling;
      //Not very sure but lets try
      //Mdelta = tiling.repr tiling.appendInverse(@endChain, @startChain)
      inv = function (c) {
        return tiling.inverse(c);
      };
      app = function (c1, c2) {
        return tiling.append(c1, c2);
      };
      // e, S bad
      // S, e bad

      // E, s good? Seems to be good, but power calculation is wrong.
      Mdelta = tiling.repr(app(inv(this.endChain), this.startChain));
      T = M.mul(M.mul(this.endOffset, Mdelta), M.hyperbolicInv(this.startOffset));
      return T;
    }

    animate(observer, stepsPerGen, generations, callback) {
      var T, Tinterp, framesBeforeGeneration, imageNameTemplate, index, totalSteps, uploadStep;
      if (!(this.startChain != null && this.endChain != null)) {
        return;
      }
      this.assertNotBusy();
      T = this.offsetMatrix();

      //Make interpolator for this matrix
      Tinterp = interpolateHyperbolic(M.hyperbolicInv(T));
      index = 0;
      totalSteps = generations * stepsPerGen;
      framesBeforeGeneration = stepsPerGen;
      imageNameTemplate = E("upload-name").value;
      this._beginWork();
      uploadStep = () => {
        var imageName, p;
        this.uploadWorker = null;
        //If we were cancelled - return quickly
        if (!this.busy) {
          return;
        }
        this.application.getObserver().navigateTo(this.startChain, this.startOffset);
        p = index / totalSteps;
        this.application.getObserver().modifyView(M.hyperbolicInv(Tinterp(p)));
        this.application.drawEverything();
        imageName = formatString(imageNameTemplate, [pad(index, 4)]);
        return this.application.uploadToServer(imageName, (ajax) => {
          //if we were cancelled, return quickly
          if (!this.busy) {
            return;
          }
          if (ajax.readyState === XMLHttpRequest.DONE && ajax.status === 200) {
            console.log("Upload success");
            index += 1;
            framesBeforeGeneration -= 1;
            if (framesBeforeGeneration === 0) {
              this.application.doStep();
              framesBeforeGeneration = stepsPerGen;
            }
            if (index <= totalSteps) {
              console.log("request next frame");
              return (this.uploadWorker = flipSetTimeout(50, uploadStep));
            } else {
              return this._endWork();
            }
          } else {
            console.log("Upload failure, cancel");
            console.log(ajax.responseText);
            return this._endWork();
          }
        });
      };
      return uploadStep();
    }
  };
}).call(this);
