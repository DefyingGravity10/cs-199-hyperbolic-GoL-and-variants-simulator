// Generated by CoffeeScript 2.7.0
(function () {
  "use strict";
  var Animator,
    Application,
    BinaryTransitionFunc,
    ButtonGroup,
    C2S,
    ChainMap,
    DayNightTransitionFunc,
    DefaultConfig,
    DomBuilder,
    E,
    FieldObserver,
    GenerateFileList,
    GenericTransitionFunc,
    GhostClickDetector,
    M,
    MIN_WIDTH,
    MouseToolCombo,
    Navigator,
    OpenDialog,
    PaintStateSelector,
    RegularTiling,
    SaveDialog,
    SvgDialog,
    UriConfig,
    ValidatingInput,
    addClass,
    application,
    autoplayCriticalPopulation,
    canvas,
    canvasSizeUpdateBlocked,
    context,
    dirty,
    doCanvasMouseDown,
    doCanvasMouseMove,
    doCanvasMouseUp,
    doCanvasTouchEnd,
    doCanvasTouchLeave,
    doCanvasTouchMove,
    doCanvasTouchStart,
    doClearMemory,
    doCloseEditor,
    doDisableGeneric,
    doEditAsGeneric,
    doExport,
    doExportClose,
    doExportVisible,
    doImport,
    doImportCancel,
    doMemorize,
    doNavigateHome,
    doOpenEditor,
    doRemember,
    doSetFixedSize,
    doSetGrid,
    doSetPanMode,
    doSetRuleGeneric,
    doShowImport,
    doStartPlayer,
    doStopPlayer,
    doTogglePlayer,
    documentWidth,
    dragHandler,
    drawEverything,
    dtMax,
    encodeVisible,
    evaluateTotalisticAutomaton,
    exportField,
    fpsDefault,
    fpsLimiting,
    getAjax,
    getCanvasCursorPosition,
    ghostClickDetector,
    importField,
    isPanMode,
    lastTime,
    memo,
    minVisibleSize,
    mouseMoveReceiver,
    parseFieldData,
    parseFloatChecked,
    parseIntChecked,
    parseTransitionFunction,
    parseUri,
    player,
    playerTimeout,
    randomFillFixedNum,
    randomFillNum,
    randomFillPercent,
    randomStateGenerator,
    redraw,
    redrawLoop,
    removeClass,
    serverSupportsUpload,
    shortcuts,
    showExportDialog,
    stringifyFieldData,
    unity,
    updateCanvasSize,
    updateGeneration,
    updateGenericRuleStatus,
    updateMemoryButtons,
    updatePlayButtons,
    updatePopulation,
    uploadToServer,
    windowHeight,
    windowWidth;

  //Core hyperbolic group compuatation library
  ({ unity } = require("../core/vondyck_chain.js"));

  ({ ChainMap } = require("../core/chain_map.js"));

  ({ RegularTiling } = require("../core/regular_tiling.js"));

  ({ evaluateTotalisticAutomaton } = require("../core/cellular_automata.js"));

  ({
    stringifyFieldData,
    parseFieldData,
    importField,
    randomFillFixedNum,
    exportField,
    randomStateGenerator
  } = require("../core/field.js"));

  ({
    GenericTransitionFunc,
    BinaryTransitionFunc,
    DayNightTransitionFunc,
    parseTransitionFunction
  } = require("../core/rule.js"));

  M = require("../core/matrix3.js");

  //Application components
  ({ Animator } = require("./animator.js"));

  ({ MouseToolCombo } = require("./mousetool.js"));

  ({ Navigator } = require("./navigator.js"));

  ({ FieldObserver } = require("./observer.js"));

  ({ GenerateFileList, OpenDialog, SaveDialog } = require("./indexeddb.js"));

  //{FieldObserverWithRemoreRenderer} = require "./observer_remote.js"

  //Misc utilities
  ({
    E,
    getAjax,
    ButtonGroup,
    windowWidth,
    windowHeight,
    documentWidth,
    removeClass,
    addClass,
    ValidatingInput
  } = require("./htmlutil.js"));

  ({ DomBuilder } = require("./dom_builder.js"));

  ({ parseIntChecked, parseFloatChecked } = require("../core/utils.js"));

  ({ parseUri } = require("./parseuri.js"));

  ({ getCanvasCursorPosition } = require("./canvas_util.js"));

  C2S = require("../ext/canvas2svg.js");

  //{lzw_encode} = require "../ext/lzw.js"
  require("../ext/polyfills.js");

  require("../core/acosh_polyfill.js");

  ({ GhostClickDetector } = require("./ghost_click_detector.js"));

  MIN_WIDTH = 100;

  minVisibleSize = 1 / 100;

  canvasSizeUpdateBlocked = false;

  randomFillNum = 2000;

  randomFillPercent = 0.4;

  // Class that "loads the default configurations"
  DefaultConfig = class DefaultConfig {
    getGrid() {
      return [7, 3];
    }

    getCellData() {
      return "";
    }

    getGeneration() {
      return 0;
    }

    getFunctionCode() {
      return "B 3 S 2 3";
    }

    getViewBase() {
      return unity;
    }

    getViewOffset() {
      return M.eye();
    }
  };

  // This function can probably be deleted for our use-case
  UriConfig = class UriConfig {
    constructor() {
      this.keys = parseUri("" + window.location).queryKey;
    }

    getGrid() {
      var e, m, match, n;
      if (this.keys.grid != null) {
        try {
          match = this.keys.grid.match(/(\d+)[,;](\d+)/);
          if (!match) {
            throw new Error(`Syntax is bad: ${this.keys.grid}`);
          }
          n = parseIntChecked(match[1]);
          m = parseIntChecked(match[2]);
          return [n, m];
        } catch (error) {
          e = error;
          alert(`Bad grid paramters: ${this.keys.grid}`);
        }
      }
      return [7, 3];
    }

    getCellData() {
      return this.keys.cells;
    }

    getGeneration() {
      var e;
      if (this.keys.generation != null) {
        try {
          return parseIntChecked(this.keys.generation);
        } catch (error) {
          e = error;
          alert(`Bad generationn umber: ${this.keys.generation}`);
        }
      }
      return 0;
    }

    getFunctionCode() {
      if (this.keys.rule != null) {
        return this.keys.rule.replace(/_/g, " ");
      } else {
        return "B 3 S 2 3";
      }
    }

    getViewBase() {
      if (this.keys.viewbase == null) {
        return unity;
      }
      return RegularTiling.prototype.parse(this.keys.viewbase);
    }

    getViewOffset() {
      var dx, dy, part, rot;
      if (this.keys.viewoffset == null) {
        return M.eye();
      }
      [rot, dx, dy] = function () {
        var i, len, ref, results;
        ref = this.keys.viewoffset.split(":");
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          results.push(parseFloatChecked(part));
        }
        return results;
      }.call(this);
      return M.mul(M.translationMatrix(dx, dy), M.rotationMatrix(rot));
    }
  };

  Application = class Application {
    constructor() {
      this.tiling = null;
      this.observer = null;
      this.navigator = null;
      this.animator = null;
      this.cells = null;
      this.generation = 0;
      this.transitionFunc = null;
      this.lastBinaryTransitionFunc = null;

      //@ObserverClass = FieldObserverWithRemoreRenderer
      this.ObserverClass = FieldObserver;
      this.margin = 16; //margin pixels
    }

    setCanvasResize(enable) {
      return (canvasSizeUpdateBlocked = enable);
    }

    getCanvasResize() {
      return canvasSizeUpdateBlocked;
    }

    redraw() {
      return redraw();
    }

    getObserver() {
      return this.observer;
    }

    drawEverything() {
      return drawEverything(canvas.width, canvas.height, context);
    }

    uploadToServer(name, cb) {
      return uploadToServer(name, cb);
    }

    getCanvas() {
      return canvas;
    }

    getTransitionFunc() {
      return this.transitionFunc;
    }

    getMargin() {
      if (this.observer.isDrawingHomePtr) {
        return this.margin;
      } else {
        return 0;
      }
    }

    setShowLiveBorders(isDrawing) {
      this.observer.isDrawingLiveBorders = isDrawing;
      return redraw();
    }

    setDrawingHomePtr(isDrawing) {
      this.observer.isDrawingHomePtr = isDrawing;
      redraw();
      if (typeof localStorage !== "undefined" && localStorage !== null) {
        localStorage.setItem("observer.isDrawingHomePtr", isDrawing ? "1" : "0");
        return console.log(`store ${isDrawing}`);
      }
    }

    //Convert canvas X,Y coordinates to relative X,Y in (0..1) range
    canvas2relative(x, y) {
      var isize, s;
      s = Math.min(canvas.width, canvas.height) - 2 * this.getMargin();
      isize = 2.0 / s;
      return [(x - canvas.width * 0.5) * isize, (y - canvas.height * 0.5) * isize];
    }

    initialize(config = new DefaultConfig()) {
      var cellData, isDrawing, m, n;
      [n, m] = config.getGrid();
      this.tiling = new RegularTiling(n, m);
      cellData = config.getCellData();
      if (cellData) {
        console.log(`import: ${cellData}`);
        this.importData(cellData);
      } else {
        this.cells = new ChainMap();
        this.cells.put(unity, 1);
      }
      this.observer = new this.ObserverClass(
        this.tiling,
        minVisibleSize,
        config.getViewBase(),
        config.getViewOffset()
      );
      if (
        (isDrawing =
          typeof localStorage !== "undefined" && localStorage !== null
            ? localStorage.getItem("observer.isDrawingHomePtr")
            : void 0) != null
      ) {
        isDrawing = isDrawing === "1";
        E("flag-origin-mark").checked = isDrawing;
        this.observer.isDrawingHomePtr = isDrawing;
        console.log(`restore ${isDrawing}`);
      } else {
        this.setDrawingHomePtr(E("flag-origin-mark").checked);
        this.setShowLiveBorders(E("flag-live-borders").checked);
      }
      this.observer.onFinish = function () {
        return redraw();
      };
      this.navigator = new Navigator(this);
      this.animator = new Animator(this);
      this.paintStateSelector = new PaintStateSelector(
        this,
        E("state-selector"),
        E("state-selector-buttons")
      );
      this.transitionFunc = parseTransitionFunction(
        config.getFunctionCode(),
        application.tiling.n,
        application.tiling.m
      );
      this.lastBinaryTransitionFunc = this.transitionFunc;
      this.openDialog = new OpenDialog(this);
      this.saveDialog = new SaveDialog(this);
      this.svgDialog = new SvgDialog(this);
      this.ruleEntry = new ValidatingInput(
        E("rule-entry"),
        (ruleStr) => {
          console.log("Parsing TF {@tiling.n} {@tiling.m}");
          return parseTransitionFunction(ruleStr, this.tiling.n, this.tiling.m);
        },
        function (rule) {
          return "" + rule;
        },
        this.transitionFunc
      );
      this.ruleEntry.onparsed = (rule) => {
        return this.doSetRule();
      };
      this.updateRuleEditor();
      return this.updateGridUI();
    }

    updateRuleEditor() {
      switch (this.transitionFunc.getType()) {
        case "binary":
          E("controls-rule-simple").style.display = "";
          return (E("controls-rule-generic").style.display = "none");
        case "custom":
          E("controls-rule-simple").style.display = "none";
          return (E("controls-rule-generic").style.display = "");
        default:
          console.dir(this.transitionFunc);
          throw new Error("Bad transition func");
      }
    }

    doSetRule() {
      var ref;
      if (this.ruleEntry.message != null) {
        alert(`Failed to parse function: ${this.ruleEntry.message}`);
        this.transitionFunc =
          (ref = this.lastBinaryTransitionFunc) != null ? ref : this.transitionFunc;
      } else {
        console.log("revalidate");
        this.ruleEntry.revalidate();
        this.transitionFunc = this.ruleEntry.value;
        this.lastBinaryTransitionFunc = this.transitionFunc;
      }
      this.paintStateSelector.update(this.transitionFunc);
      console.log(this.transitionFunc);
      E("controls-rule-simple").style.display = "";
      return (E("controls-rule-generic").style.display = "none");
    }

    setGridImpl(n, m) {
      var oldObserver, ref, ref1;
      this.tiling = new RegularTiling(n, m);
      //transition function should be changed too.
      if (this.transitionFunc != null) {
        this.transitionFunc = this.transitionFunc.changeGrid(this.tiling.n, this.tiling.m);
      }
      if ((ref = this.observer) != null) {
        ref.shutdown();
      }
      oldObserver = this.observer;
      this.observer = new this.ObserverClass(this.tiling, minVisibleSize);
      this.observer.isDrawingHomePtr = oldObserver.isDrawingHomePtr;
      this.observer.onFinish = function () {
        return redraw();
      };
      if ((ref1 = this.navigator) != null) {
        ref1.clear();
      }
      doClearMemory();
      doStopPlayer();
      return this.updateGridUI();
    }

    updateGridUI() {
      E("entry-n").value = "" + application.tiling.n;
      E("entry-m").value = "" + application.tiling.m;
      return (E("grid-num-neighbors").innerHTML = (this.tiling.m - 2) * this.tiling.n);
    }

    //Actions
    doRandomFill() {
      randomFillFixedNum(
        this.cells,
        randomFillPercent,
        unity,
        randomFillNum,
        this.tiling,
        randomStateGenerator(this.transitionFunc.numStates)
      );
      updatePopulation();
      return redraw();
    }

    doStep(onFinish) {
      //Set generation for thse rules who depend on it
      this.transitionFunc.setGeneration(this.generation);
      this.cells = evaluateTotalisticAutomaton(
        this.cells,
        this.tiling,
        this.transitionFunc.evaluate.bind(this.transitionFunc),
        this.transitionFunc.plus,
        this.transitionFunc.plusInitial
      );
      this.generation += 1;
      redraw();
      updatePopulation();
      updateGeneration();
      return typeof onFinish === "function" ? onFinish() : void 0;
    }

    doReset() {
      this.cells = new ChainMap();
      this.generation = 0;
      this.cells.put(unity, 1);
      updatePopulation();
      updateGeneration();
      return redraw();
    }

    doSearch() {
      var found;
      found = this.navigator.search(this.cells);
      updateCanvasSize();
      if (found > 0) {
        return this.navigator.navigateToResult(0);
      }
    }

    importData(data) {
      var e, m, match, n, normalizeChain;
      try {
        console.log(`importing ${data}`);
        match = data.match(/^(\d+)\$(\d+)\$(.*)$/);
        if (match == null) {
          throw new Error("Data format unrecognized");
        }
        n = parseIntChecked(match[1]);
        m = parseIntChecked(match[2]);
        if (n !== this.tiling.n || m !== this.tiling.m) {
          console.log("Need to change grid");
          this.setGridImpl(n, m);
        }
        //normzlize chain coordinates, so that importing of user-generated data could be possible
        normalizeChain = (chain) => {
          return this.tiling.toCell(this.tiling.rewrite(chain));
        };
        this.cells = importField(parseFieldData(match[3]), null, normalizeChain);
        return console.log(`Imported ${this.cells.count} cells`);
      } catch (error) {
        e = error;
        alert(`Faield to import data: ${e}`);
        return (this.cells = new ChainMap());
      }
    }

    loadData(record, cellData) {
      var assert;
      assert = function (x) {
        if (x == null) {
          throw new Error("Assertion failure");
        }
        return x;
      };
      this.setGridImpl(assert(record.gridN), assert(record.gridM));
      this.animator.reset();
      this.cells = importField(parseFieldData(assert(cellData)));
      this.generation = assert(record.generation);
      this.observer.navigateTo(this.tiling.parse(assert(record.base)), assert(record.offset));
      console.log(`LOading func type= ${record.funcType}`);
      switch (record.funcType) {
        case "binary":
          this.transitionFunc = parseTransitionFunction(record.funcId, record.gridN, record.gridM);
          this.ruleEntry.setValue(this.transitionFunc);
          break;
        case "custom":
          this.transitionFunc = new GenericTransitionFunc(record.funcId);
          this.paintStateSelector.update(this.transitionFunc);
          break;
        default:
          throw new Error(`unknown TF type ${record.funcType}`);
      }
      updatePopulation();
      updateGeneration();
      this.updateRuleEditor();
      return redraw();
    }

    getSaveData(fname) {
      var catalogRecord, fieldData, funcId, funcType;
      //[data, catalogRecord]
      fieldData = stringifyFieldData(exportField(this.cells));
      funcId = "" + this.getTransitionFunc();
      funcType = this.getTransitionFunc().getType();
      catalogRecord = {
        gridN: this.tiling.n,
        gridM: this.tiling.m,
        name: fname,
        funcId: funcId,
        funcType: funcType,
        base: this.getObserver().getViewCenter().toString(),
        offset: this.getObserver().getViewOffsetMatrix(),
        size: fieldData.length,
        time: Date.now(),
        field: null,
        generation: this.generation
      };
      return [fieldData, catalogRecord];
    }

    toggleCellAt(x, y) {
      var cell, e, xp, yp;
      [xp, yp] = this.canvas2relative(x, y);
      try {
        cell = this.observer.cellFromPoint(xp, yp);
      } catch (error) {
        e = error;
        return;
      }
      if (this.cells.get(cell) === this.paintStateSelector.state) {
        this.cells.remove(cell);
      } else {
        this.cells.put(cell, this.paintStateSelector.state);
      }
      return redraw();
    }

    doExportSvg() {
      var svgContext, sz;
      sz = 512;
      svgContext = new C2S(sz, sz);
      drawEverything(sz, sz, svgContext);
      // Show the generated SVG image
      return this.svgDialog.show(svgContext.getSerializedSvg());
    }

    // Can probably delete this function
    doExportUrl() {
      /* var basePath, dx, dy, keys, rot, ruleStr, uri;
      //Export field state as URL
      keys = [];
      keys.push(`grid=${this.tiling.n},${this.tiling.m}`);
      if (this.cells.count !== 0) {
        keys.push(
          `cells=${this.tiling.n}$${this.tiling.m}$${stringifyFieldData(
            exportField(this.cells)
          )}`
        );
      }
      keys.push(`generation=${this.generation}`);
      if (this.transitionFunc.getType() === "binary") {
        ruleStr = "" + this.transitionFunc;
        ruleStr = ruleStr.replace(/\s/g, "_");
        keys.push(`rule=${ruleStr}`);
      }
      keys.push(`viewbase=${this.getObserver().getViewCenter()}`);
      [rot, dx, dy] = M.hyperbolicDecompose(
        this.getObserver().getViewOffsetMatrix()
      );
      keys.push(`viewoffset=${rot}:${dx}:${dy}`);
      basePath = location.href.replace(location.search, "");
      uri = basePath + "?" + keys.join("&");
      return showExportDialog(uri); */
    }
  };

  SvgDialog = class SvgDialog {
    constructor(application1) {
      this.application = application1;
      this.dialog = E("svg-export-dialog");
      this.imgContainer = E("svg-image-container");
    }

    close() {
      this.imgContainer.innerHTML = "";
      return (this.dialog.style.display = "none");
    }

    show(svg) {
      var dataUri, dom;
      dataUri = "data:image/svg+xml;utf8," + encodeURIComponent(svg);
      dom = new DomBuilder();
      dom
        .tag("img")
        .a("src", dataUri)
        .a("alt", "SVG image")
        .a("title", "Use right click to save SVG image")
        .end();
      this.imgContainer.innerHTML = "";
      this.imgContainer.appendChild(dom.finalize());
      //@imgContainer.innerHTML = svg
      return (this.dialog.style.display = "");
    }
  };

  updateCanvasSize = function () {
    var canvasRect, containerAvail, docW, h, navWrap, usedWidth, w, winH, winW;
    if (canvasSizeUpdateBlocked) {
      return;
    }
    docW = documentWidth();
    winW = windowWidth();
    if (docW > winW) {
      console.log("overflow");
      usedWidth = docW - canvas.width;
      //console.log "#Win: #{windowWidth()}, doc: #{documentWidth()}, used: #{usedWidth}"
      w = winW - usedWidth;
    } else {
      //console.log "underflow"
      containerAvail = E("canvas-container").clientWidth;
      //console.log "awail width: #{containerAvail}"
      w = containerAvail;
    }
    //now calculae available height
    canvasRect = canvas.getBoundingClientRect();
    winH = windowHeight();
    h = winH - canvasRect.top;
    navWrap = E("navigator-wrap");
    navWrap.style.height = `${winH - navWrap.getBoundingClientRect().top - 16}px`;
    //get the smaller of both
    w = Math.min(w, h);

    //reduce it a bit
    w -= 16;

    //make width multiple of 16
    w = w & ~15;

    //console.log "New w is #{w}"
    if (w <= MIN_WIDTH) {
      w = MIN_WIDTH;
    }
    if (canvas.width !== w) {
      canvas.width = canvas.height = w;
      redraw();
      E("image-size").value = "" + w;
    }
  };

  doSetFixedSize = function (isFixed) {
    var size;
    if (isFixed) {
      size = parseIntChecked(E("image-size").value);
      if (size <= 0 || size >= 65536) {
        throw new Error(`Bad size: ${size}`);
      }
      canvasSizeUpdateBlocked = true;
      canvas.width = canvas.height = size;
      return redraw();
    } else {
      canvasSizeUpdateBlocked = false;
      return updateCanvasSize();
    }
  };

  PaintStateSelector = class PaintStateSelector {
    constructor(application1, container, buttonContainer) {
      this.application = application1;
      this.container = container;
      this.buttonContainer = buttonContainer;
      this.state = 1;
      this.numStates = 2;
    }

    update() {
      var btnId, color, dom, i, id2state, numStates, ref, state;
      numStates = this.application.getTransitionFunc().numStates;
      //only do something if number of states changed
      if (numStates === this.numStates) {
        return;
      }
      this.numStates = numStates;
      console.log(`Num states changed to ${numStates}`);
      if (this.state >= numStates) {
        this.state = 1;
      }
      this.buttonContainer.innerHTML = "";
      if (numStates <= 2) {
        this.container.style.display = "none";
        this.buttons = null;
        return (this.state2id = null);
      } else {
        this.container.style.display = "";
        dom = new DomBuilder();
        id2state = {};
        this.state2id = {};
        for (
          state = i = 1, ref = numStates;
          1 <= ref ? i < ref : i > ref;
          state = 1 <= ref ? ++i : --i
        ) {
          color = this.application.observer.getColorForState(state);
          btnId = `select-state-${state}`;
          this.state2id[state] = btnId;
          id2state[btnId] = state;
          dom
            .tag("button")
            .store("btn")
            .CLASS(state === this.state ? "btn-selected" : "")
            .ID(btnId)
            .a("style", `background-color:${color}`)
            .text("" + state)
            .end();
        }
        //dom.vars.btn.onclick = (e)->
        this.buttonContainer.appendChild(dom.finalize());
        this.buttons = new ButtonGroup(this.buttonContainer, "button");
        return this.buttons.addEventListener("change", (e, btnId, oldBtn) => {
          if ((state = id2state[btnId]) != null) {
            return (this.state = state);
          }
        });
      }
    }

    setState(newState) {
      if (newState === this.state) {
        return;
      }
      if (this.state2id[newState] == null) {
        return;
      }
      this.state = newState;
      if (this.buttons) {
        return this.buttons.setButton(this.state2id[newState]);
      }
    }
  };

  serverSupportsUpload = function () {
    return ("" + window.location).match(/:8000\//) && true;
  };

  // ============================================  app code ===============

  /* if (serverSupportsUpload()) {
    console.log("Enable upload");
    E("animate-controls").style.display = "";
  } */

  canvas = E("canvas");

  context = canvas.getContext("2d");

  dragHandler = null;

  ghostClickDetector = new GhostClickDetector();

  player = null;

  playerTimeout = 500;

  autoplayCriticalPopulation = 90000;

  doStartPlayer = function () {
    var runPlayerStep;
    if (player != null) {
      return;
    }
    runPlayerStep = function () {
      if (application.cells.count >= autoplayCriticalPopulation) {
        alert(`Population reached ${application.cells.count}, stopping auto-play`);
        player = null;
      } else {
        player = setTimeout(function () {
          return application.doStep(runPlayerStep);
        }, playerTimeout);
      }
      return updatePlayButtons();
    };
    return runPlayerStep();
  };

  doStopPlayer = function () {
    if (player) {
      clearTimeout(player);
      player = null;
      return updatePlayButtons();
    }
  };

  doTogglePlayer = function () {
    if (player) {
      return doStopPlayer();
    } else {
      return doStartPlayer();
    }
  };

  updateGenericRuleStatus = function (status) {
    var span;
    span = E("generic-tf-status");
    span.innerHTML = status;
    return span.setAttribute("class", "generic-tf-status-#{status.toLowerCase()}");
  };

  updatePlayButtons = function () {
    E("btn-play-start").style.display = player ? "none" : "";
    return (E("btn-play-stop").style.display = !player ? "none" : "");
  };

  dirty = true;

  redraw = function () {
    return (dirty = true);
  };

  drawEverything = function (w, h, context) {
    var s, s1;
    if (!application.observer.canDraw()) {
      return false;
    }
    context.fillStyle = "white";
    //context.clearRect 0, 0, canvas.width, canvas.height
    context.fillRect(0, 0, w, h);
    context.save();
    s = Math.min(w, h) / 2;
    s1 = s - application.getMargin();
    context.translate(s, s);
    application.observer.draw(application.cells, context, s1);
    context.restore();
    return true;
  };

  fpsLimiting = true;

  lastTime = Date.now();

  fpsDefault = 30;

  dtMax = 1000.0 / fpsDefault;

  redrawLoop = function () {
    var t, tDraw;
    if (dirty) {
      if (!fpsLimiting || (t = Date.now()) - lastTime > dtMax) {
        if (drawEverything(canvas.width, canvas.height, context)) {
          tDraw = Date.now() - t;
          //adaptively update FPS
          dtMax = dtMax * 0.9 + tDraw * 2 * 0.1;
          dirty = false;
        }
        lastTime = t;
      }
    }
    return requestAnimationFrame(redrawLoop);
  };

  isPanMode = true;

  doCanvasMouseDown = function (e) {
    var isPanAction, x, y;
    //Allow normal right-click to support image sacing
    E("canvas-container").focus();
    if (e.button === 2) {
      return;
    }
    if (typeof canvas.setCapture === "function") {
      canvas.setCapture(true);
    }
    e.preventDefault();
    [x, y] = getCanvasCursorPosition(e, canvas);
    isPanAction = (e.button === 1) ^ e.shiftKey ^ isPanMode;
    if (!isPanAction) {
      application.toggleCellAt(x, y);
      return updatePopulation();
    } else {
      return (dragHandler = new MouseToolCombo(application, x, y));
    }
  };

  doCanvasMouseUp = function (e) {
    e.preventDefault();
    if (dragHandler !== null) {
      if (dragHandler != null) {
        dragHandler.mouseUp(e);
      }
      return (dragHandler = null);
    }
  };

  doCanvasTouchStart = function (e) {
    if (e.touches.length === 1) {
      doCanvasMouseDown(e);
      return e.preventDefault();
    }
  };

  doCanvasTouchLeave = function (e) {
    return doCanvasMouseOut(e);
  };

  doCanvasTouchEnd = function (e) {
    e.preventDefault();
    return doCanvasMouseUp(e);
  };

  doCanvasTouchMove = function (e) {
    return doCanvasMouseMove(e);
  };

  doSetPanMode = function (mode) {
    var bedit, bpan;
    isPanMode = mode;
    bpan = E("btn-mode-pan");
    bedit = E("btn-mode-edit");
    removeClass(bpan, "button-active");
    removeClass(bedit, "button-active");
    return addClass(isPanMode ? bpan : bedit, "button-active");
  };

  doCanvasMouseMove = function (e) {
    var isPanAction;
    isPanAction = e.shiftKey ^ isPanMode;
    E("canvas-container").style.cursor = isPanAction ? "move" : "default";
    if (dragHandler !== null) {
      e.preventDefault();
      return dragHandler.mouseMoved(e);
    }
  };

  doOpenEditor = function () {
    E("generic-tf-code").value = application.transitionFunc.code;
    return (E("generic-tf-editor").style.display = "");
  };

  doCloseEditor = function () {
    return (E("generic-tf-editor").style.display = "none");
  };

  doSetRuleGeneric = function () {
    var e;
    try {
      console.log("Set generic rule");
      application.transitionFunc = new GenericTransitionFunc(E("generic-tf-code").value);
      updateGenericRuleStatus("Compiled");
      application.paintStateSelector.update(application.transitionFunc);
      application.updateRuleEditor();
      E("controls-rule-simple").style.display = "none";
      E("controls-rule-generic").style.display = "";
      return true;
    } catch (error) {
      e = error;
      alert(`Failed to parse function: ${e}`);
      updateGenericRuleStatus("Error");
      return false;
    }
  };

  doSetGrid = function () {
    var e, m, n;
    try {
      n = parseInt(E("entry-n").value, 10);
      m = parseInt(E("entry-m").value, 10);
      if (Number.isNaN(n) || n <= 0) {
        throw new Error("Parameter N is bad");
      }
      if (Number.isNaN(m) || m <= 0) {
        throw new Error("Parameter M is bad");
      }
      //if 1/n + 1/m <= 1/2
      if (2 * (n + m) >= n * m) {
        throw new Error(`Tessellation {${n}; ${m}} is not hyperbolic and not supported.`);
      }
    } catch (error) {
      e = error;
      alert("" + e);
      return;
    }
    application.setGridImpl(n, m);
    application.doReset();
    return application.animator.reset();
  };

  updatePopulation = function () {
    return (E("population").innerHTML = "" + application.cells.count);
  };

  updateGeneration = function () {
    return (E("generation").innerHTML = "" + application.generation);
  };

  //exportTrivial = (cells) ->
  //  parts = []
  //  cells.forItems (cell, value)->
  //    parts.push ""+cell
  //    parts.push ""+value
  //  return parts.join " "
  doExport = function () {
    var data, m, n;
    data = stringifyFieldData(exportField(application.cells));
    n = application.tiling.n;
    m = application.tiling.m;
    return showExportDialog(`${n}$${m}$${data}`);
  };

  doExportClose = function () {
    return (E("export-dialog").style.display = "none");
  };

  uploadToServer = function (imgname, callback) {
    var cb, dataURL;
    dataURL = canvas.toDataURL();
    cb = function (blob) {
      var ajax, formData;
      formData = new FormData();
      formData.append("file", blob, imgname);
      ajax = getAjax();
      ajax.open("POST", "/uploads/", false);
      ajax.onreadystatechange = function () {
        return callback(ajax);
      };
      return ajax.send(formData);
    };
    return canvas.toBlob(cb, "image/png");
  };

  memo = null;

  doMemorize = function () {
    memo = {
      cells: application.cells.copy(),
      viewCenter: application.observer.getViewCenter(),
      viewOffset: application.observer.getViewOffsetMatrix(),
      generation: application.generation
    };
    console.log("Position memoized");
    return updateMemoryButtons();
  };

  doRemember = function () {
    if (memo === null) {
      return console.log("nothing to remember");
    } else {
      application.cells = memo.cells.copy();
      application.generation = memo.generation;
      application.observer.navigateTo(memo.viewCenter, memo.viewOffset);
      updatePopulation();
      return updateGeneration();
    }
  };

  doClearMemory = function () {
    memo = null;
    return updateMemoryButtons();
  };

  updateMemoryButtons = function () {
    return (E("btn-mem-get").disabled = E("btn-mem-clear").disabled = memo === null);
  };

  encodeVisible = function () {
    var cell, i, iCenter, len, ref, state, translatedCell, visibleCells;
    iCenter = application.tiling.inverse(application.observer.cellFromPoint(0, 0));
    visibleCells = new ChainMap();
    ref = application.observer.visibleCells(application.cells);
    for (i = 0, len = ref.length; i < len; i++) {
      [cell, state] = ref[i];
      translatedCell = application.tiling.append(iCenter, cell);
      translatedCell = application.tiling.toCell(translatedCell);
      visibleCells.put(translatedCell, state);
    }
    return exportField(visibleCells);
  };

  showExportDialog = function (sdata) {
    E("export").value = sdata;
    E("export-dialog").style.display = "";
    E("export").focus();
    return E("export").select();
  };

  doExportVisible = function () {
    var data, m, n;
    n = application.tiling.n;
    m = application.tiling.m;
    data = stringifyFieldData(encodeVisible());
    return showExportDialog(`${n}$${m}$${data}`);
  };

  doShowImport = function () {
    E("import-dialog").style.display = "";
    return E("import").focus();
  };

  doImportCancel = function () {
    E("import-dialog").style.display = "none";
    return (E("import").value = "");
  };

  doImport = function () {
    var e;
    try {
      application.importData(E("import").value);
      updatePopulation();
      redraw();
      E("import-dialog").style.display = "none";
      return (E("import").value = "");
    } catch (error) {
      e = error;
      return alert(`Error parsing: ${e}`);
    }
  };

  doEditAsGeneric = function () {
    application.transitionFunc = application.transitionFunc.toGeneric();
    updateGenericRuleStatus("Compiled");
    application.paintStateSelector.update(application.transitionFunc);
    application.updateRuleEditor();
    return doOpenEditor();
  };

  doDisableGeneric = function () {
    return application.doSetRule();
  };

  doNavigateHome = function () {
    return application.observer.navigateTo(unity);
  };

  // ============ Bind Events =================
  E("btn-reset").addEventListener("click", function () {
    return application.doReset();
  });

  E("btn-step").addEventListener("click", function () {
    return application.doStep();
  });

  mouseMoveReceiver = E("canvas-container");

  mouseMoveReceiver.addEventListener("mousedown", function (e) {
    if (!ghostClickDetector.isGhost) {
      return doCanvasMouseDown(e);
    }
  });

  mouseMoveReceiver.addEventListener("mouseup", function (e) {
    if (!ghostClickDetector.isGhost) {
      return doCanvasMouseUp(e);
    }
  });

  mouseMoveReceiver.addEventListener("mousemove", doCanvasMouseMove);

  mouseMoveReceiver.addEventListener("mousedrag", doCanvasMouseMove);

  mouseMoveReceiver.addEventListener("touchstart", doCanvasTouchStart);

  mouseMoveReceiver.addEventListener("touchend", doCanvasTouchEnd);

  mouseMoveReceiver.addEventListener("touchmove", doCanvasTouchMove);

  mouseMoveReceiver.addEventListener("touchleave", doCanvasTouchLeave);

  ghostClickDetector.addListeners(canvas);

  E("btn-set-rule").addEventListener("click", function (e) {
    return application.doSetRule();
  });

  E("btn-set-rule-generic").addEventListener("click", function (e) {
    doSetRuleGeneric();
    return doCloseEditor();
  });

  E("btn-rule-generic-close-editor").addEventListener("click", doCloseEditor);

  E("btn-set-grid").addEventListener("click", doSetGrid);

  E("btn-export").addEventListener("click", doExport);

  E("btn-search").addEventListener("click", function () {
    return application.doSearch();
  });

  E("btn-random").addEventListener("click", function () {
    return application.doRandomFill();
  });

  E("btn-rule-make-generic").addEventListener("click", doEditAsGeneric);

  E("btn-edit-rule").addEventListener("click", doOpenEditor);

  E("btn-disable-generic-rule").addEventListener("click", doDisableGeneric);

  E("btn-export-close").addEventListener("click", doExportClose);

  E("btn-import").addEventListener("click", doShowImport);

  E("btn-import-cancel").addEventListener("click", doImportCancel);

  E("btn-import-run").addEventListener("click", doImport);

  //initialize
  /* E("btn-mem-set").addEventListener("click", doMemorize);

  E("btn-mem-get").addEventListener("click", doRemember);

  E("btn-mem-clear").addEventListener("click", doClearMemory); */

  E("btn-exp-visible").addEventListener("click", doExportVisible);

  E("btn-nav-home").addEventListener("click", doNavigateHome);

  window.addEventListener("resize", updateCanvasSize);

  E("btn-nav-clear").addEventListener("click", function (e) {
    return application.navigator.clear();
  });

  E("btn-play-start").addEventListener("click", doTogglePlayer);

  E("btn-play-stop").addEventListener("click", doTogglePlayer);

  /* E("animate-set-start").addEventListener("click", function () {
    return application.animator.setStart(application.observer);
  });

  E("animate-set-end").addEventListener("click", function () {
    return application.animator.setEnd(application.observer);
  });

  E("animate-view-start").addEventListener("click", function () {
    return application.animator.viewStart(application.observer);
  });

  E("animate-view-end").addEventListener("click", function () {
    return application.animator.viewEnd(application.observer);
  });

  E("btn-animate-derotate").addEventListener("click", function () {
    return application.animator.derotate();
  });

  E("btn-upload-animation").addEventListener("click", function (e) {
    return application.animator.animate(
      application.observer,
      parseIntChecked(E("animate-frame-per-generation").value),
      parseIntChecked(E("animate-generations").value),
      function () {
        return null;
      }
    );
  });

  E("btn-animate-cancel").addEventListener("click", function (e) {
    return application.animator.cancelWork();
  });
 */
  E("view-straighten").addEventListener("click", function (e) {
    return application.observer.straightenView();
  });

  E("view-straighten").addEventListener("click", function (e) {
    return application.observer.straightenView();
  });

  E("image-fix-size").addEventListener("click", function (e) {
    return doSetFixedSize(E("image-fix-size").checked);
  });

  E("image-size").addEventListener("change", function (e) {
    E("image-fix-size").checked = true;
    return doSetFixedSize(true);
  });

  E("flag-origin-mark").addEventListener("change", function (e) {
    return application.setDrawingHomePtr(E("flag-origin-mark").checked);
  });

  E("flag-live-borders").addEventListener("change", function (e) {
    return application.setShowLiveBorders(E("flag-live-borders").checked);
  });

  E("btn-mode-edit").addEventListener("click", function (e) {
    return doSetPanMode(false);
  });

  E("btn-mode-pan").addEventListener("click", function (e) {
    return doSetPanMode(true);
  });

  E("btn-db-save").addEventListener("click", function (e) {
    return application.saveDialog.show();
  });

  E("btn-db-load").addEventListener("click", function (e) {
    return application.openDialog.show();
  });

  E("btn-export-svg").addEventListener("click", function (e) {
    return application.doExportSvg();
  });

  E("btn-svg-export-dialog-close").addEventListener("click", function (e) {
    return application.svgDialog.close();
  });

  // This portion also seems removable
  /* E("btn-export-uri").addEventListener("click", function (e) {
    return application.doExportUrl();
  }); */

  shortcuts = {
    N: function () {
      return application.doStep();
    },
    C: function () {
      return application.doReset();
    },
    S: function () {
      return application.doSearch();
    },
    R: function () {
      return application.doRandomFill();
    },
    1: function (e) {
      return application.paintStateSelector.setState(1);
    },
    2: function (e) {
      return application.paintStateSelector.setState(2);
    },
    3: function (e) {
      return application.paintStateSelector.setState(3);
    },
    4: function (e) {
      return application.paintStateSelector.setState(4);
    },
    5: function (e) {
      return application.paintStateSelector.setState(5);
    },
    M: doMemorize,
    U: doRemember,
    UA: doClearMemory,
    H: doNavigateHome,
    G: doTogglePlayer,
    SA: function (e) {
      return application.observer.straightenView();
    },
    "#32": doTogglePlayer,
    P: function (e) {
      return doSetPanMode(true);
    },
    E: function (e) {
      return doSetPanMode(false);
    },
    SC: function (e) {
      return application.saveDialog.show();
    },
    OC: function (e) {
      return application.openDialog.show();
    }
  };

  document.addEventListener("keydown", function (e) {
    var focused, handler, keyCode, ref;
    focused = document.activeElement;
    if (focused && ((ref = focused.tagName.toLowerCase()) === "textarea" || ref === "input")) {
      return;
    }
    keyCode = e.keyCode > 32 && e.keyCode < 128 ? String.fromCharCode(e.keyCode) : "#" + e.keyCode;
    if (e.ctrlKey) {
      keyCode += "C";
    }
    if (e.altKey) {
      keyCode += "A";
    }
    if (e.shiftKey) {
      keyCode += "S";
    }
    //console.log keyCode
    if ((handler = shortcuts[keyCode]) != null) {
      e.preventDefault();
      return handler(e);
    }
  });

  //#Application startup
  application = new Application();

  application.initialize(new UriConfig());

  doSetPanMode(true);

  updatePopulation();

  updateGeneration();

  updateCanvasSize();

  updateMemoryButtons();

  updatePlayButtons();

  redrawLoop();

  //application.saveDialog.show()
}).call(this);
