// Generated by CoffeeScript 2.7.0
(function () {
  "use strict";
  var FieldObserver, FieldObserverWithRemoreRenderer, runCommands;

  ({ FieldObserver } = require("./observer.js"));

  ({ runCommands } = require("./context_delegate.js"));

  exports.FieldObserverWithRemoreRenderer =
    FieldObserverWithRemoreRenderer = class FieldObserverWithRemoreRenderer extends FieldObserver {
      constructor(tessellation, appendRewrite, minCellSize = 1.0 / 400.0) {
        super(tessellation, appendRewrite, minCellSize);
        this.worker = new Worker("./render_worker.js");
        console.log(`Worker created: ${this.worker}`);
        this.worker.onmessage = (e) => {
          return this.onMessage(e);
        };
        this.cellShapes = null;
        this.workerReady = false;
        this.rendering = true;
        this.cellSetState = 0;
        this.worker.postMessage([
          "I",
          [tessellation.group.n, tessellation.group.m, this.cellTransforms],
        ]);
        this.postponedRenderRequest = null;
      }

      _observedCellsChanged() {
        console.log("Ignore all responces before answer...");
        this.cellShapes = null;
        this.cellSetState += 1;
      }

      onMessage(e) {
        //console.log "message received: #{JSON.stringify e.data}"
        switch (e.data[0]) {
          case "I":
            this.onInitialized(...e.data[1]);
            break;
          case "R":
            this.renderFinished(e.data[1], e.data[2]);
            break;
          default:
            throw new Error(`Unexpected answer from worker: ${JSON.stringify(e.data)}`);
        }
      }

      onInitialized(n, m) {
        if (n === this.tessellation.group.n && m === this.tessellation.group.m) {
          console.log("Worker initialized");
          return (this.workerReady = true);
        } else {
          //now waiting for first rendered field.
          return console.log("Init OK message received, but mismatched. Probably, late message");
        }
      }

      _runPostponed() {
        if (this.postponedRenderRequest !== null) {
          this.renderGrid(this.postponedRenderRequest);
          return (this.postponedRenderRequest = null);
        }
      }

      renderFinished(renderedCells, cellSetState) {
        //console.log "worker finished rendering #{renderedCells.length} cells"
        this.rendering = false;
        if (cellSetState === this.cellSetState) {
          this.cellShapes = renderedCells;
          if (typeof this.onFinish === "function") {
            this.onFinish();
          }
        }
        //else
        //  console.log "mismatch cell states: answer for #{cellSetState}, but current is #{@cellSetState}"
        return this._runPostponed();
      }

      renderGrid(viewMatrix) {
        if (this.rendering || !this.workerReady) {
          return (this.postponedRenderRequest = viewMatrix);
        } else {
          this.rendering = true;
          return this.worker.postMessage(["R", viewMatrix, this.cellSetState]);
        }
      }

      canDraw() {
        return this.cellShapes && this.workerReady;
      }

      draw(cells, context) {
        var cell, i, j, k, len, len1, ref, ref1;
        if (this.cellShapes === null) {
          console.log("cell shapes null");
        }
        if (!this.cellShapes || !this.workerReady) {
          return false;
        }
        //first borders
        if (this.drawEmpty) {
          context.beginPath();
          ref = this.cells;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            cell = ref[i];
            if (!cells.get(cell)) {
              runCommands(context, this.cellShapes[i]);
            }
          }
          context.stroke();
        }
        //then cells
        context.beginPath();
        ref1 = this.cells;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          cell = ref1[i];
          if (cells.get(cell)) {
            runCommands(context, this.cellShapes[i]);
          }
        }
        context.fill();
        return true;
      }

      shutdown() {
        return this.worker.terminate();
      }
    };
}).call(this);
