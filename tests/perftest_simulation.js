// Generated by CoffeeScript 2.7.0
(function() {
  //Performance testing

  var ChainMap, RandomGenerator, RegularTiling, evaluateTotalisticAutomaton, parseTransitionFunction, randomFillBlob, randomFillFixedNum, runTestMildGrowing, unity;

  ({randomFillFixedNum} = require("../src/core/field.coffee"));

  ({ChainMap} = require("../src/core/chain_map.coffee"));

  ({RegularTiling} = require("../src/core/regular_tiling.coffee"));

  ({parseTransitionFunction} = require("../src/core/rule.coffee"));

  ({evaluateTotalisticAutomaton} = require("../src/core/cellular_automata.coffee"));

  ({unity} = require("../src/core/vondyck_chain.coffee"));

  RandomGenerator = class RandomGenerator {
    //From here: http://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator
    constructor(seed) {
      this.m = 0x80000000; // 2**31
      this.a = 1103515245;
      this.c = 12345;
      this.state = seed != null ? seed : Math.floor(Math.random() * (this.m - 1));
    }

    nextInt() {
      return this.state = (this.a * this.state + this.c) % this.m;
    }

    // returns in range [0,1]
    nextFloat() {
      return this.nextInt() / (this.m - 1);
    }

    // returns in range [start, end): including start, excluding end
    // can't modulu nextInt because of weak randomness in lower bits
    nextRange(start, end) {
      var randomUnder1, rangeSize;
      rangeSize = end - start;
      randomUnder1 = this.nextInt() / this.m;
      return start + Math.floor(randomUnder1 * rangeSize);
    }

    choice(array) {
      return array[this.nextRange(0, array.length)];
    }

  };

  //Fill randomly, visiting numCells cells around the origin
  randomFillBlob = function(field, tiling, numCells, randomState) {
    var visited;
    visited = 0;
    tiling.forFarNeighborhood(unity, function(cell, _) {
      var state;
      if (visited >= numCells) {
        //Time to stop iteration?
        return false;
      }
      if ((state = randomState()) !== 0) {
        field.put(cell, state);
      }
      visited += 1;
      //Continue
      return true;
    });
  };

  runTestMildGrowing = function(seed) {
    var density, field, generation, maxCells, maxPop, newState, rng, rule, steps, tiling;
    rng = new RandomGenerator(seed);
    tiling = new RegularTiling(3, 8);
    rule = parseTransitionFunction("B 3 S 2 6", tiling.n, tiling.m);
    density = 0.4;
    newState = function() {
      if (rng.nextFloat() < density) {
        return 1;
      } else {
        return 0;
      }
    };
    maxCells = 4000;
    steps = 1000;
    maxPop = 20000;
    field = new ChainMap();
    randomFillBlob(field, tiling, maxCells, newState);
    console.log(`Rule is: ${rule}`);
    generation = 0;
    console.time("eval");
    while ((field.count < maxPop) && ((generation += 1) < steps)) {
      field = evaluateTotalisticAutomaton(field, tiling, rule.evaluate.bind(rule), rule.plus, rule.plusInitial);
    }
    //console.log "g: #{generation}, pop: #{field.count}"
    return console.timeEnd("eval");
  };

  runTestMildGrowing(100);

  runTestMildGrowing(101);

  runTestMildGrowing(102);

}).call(this);
