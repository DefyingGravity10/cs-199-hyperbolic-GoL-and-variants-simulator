// Generated by CoffeeScript 2.7.0
(function() {
  var RewriteRuleset, assert, chain2string, extendLastPowerRewriteTable, makeAppendRewrite, makeAppendRewriteRef, newNode, string2chain, unity;

  assert = require("assert");

  ({RewriteRuleset} = require("../src/core/knuth_bendix.coffee"));

  ({string2chain, chain2string, makeAppendRewriteRef, makeAppendRewrite, extendLastPowerRewriteTable} = require("../src/core/vondyck_rewriter.coffee"));

  ({unity, newNode} = require("../src/core/vondyck_chain.coffee"));

  describe("string2chain", function() {
    it("must convert empty string", function() {
      return assert.equal(unity, string2chain(""));
    });
    it("must convert  nonempty strings", function() {
      assert(string2chain("a").equals(newNode('a', 1, unity)));
      assert(string2chain("A").equals(newNode('a', -1, unity)));
      assert(string2chain("aa").equals(newNode('a', 2, unity)));
      return assert(string2chain("AA").equals(newNode('a', -2, unity)));
    });
    return it("must convert complex chains", function() {});
  });

  //Todo
  describe("chain2string", function() {
    it("must convert empty chain", function() {
      return assert.equal(chain2string(unity), "");
    });
    it("must convert simple nonempty chain", function() {
      assert.equal(chain2string(newNode('a', 2, unity)), "aa");
      assert.equal(chain2string(newNode('a', -3, unity)), "AAA");
      return assert.equal(chain2string(newNode('b', 1, unity)), "b");
    });
    return it("must convert complex nonempty chain", function() {
      var c;
      c = newNode('a', -1, newNode('b', -3, newNode('a', 2, unity)));
      return assert.equal(chain2string(c), "aaBBBA");
    });
  });

  describe("Compiled rewriter", function() {
    var compiledRewriter, doTest, m, n, refRewriter, rewriteTable, walkChains;
    rewriteTable = new RewriteRuleset({
      aaBaa: 'AAbAA',
      ABaBA: 'bAAb',
      bb: 'BB',
      bAB: 'BBa',
      aaa: 'AA',
      AAA: 'aa',
      ab: 'BA',
      aBB: 'BAb',
      ba: 'AB',
      Bb: '',
      bB: '',
      Aa: '',
      aA: '',
      BBB: 'b',
      BAB: 'a',
      ABA: 'b',
      aaBA: 'AAb',
      ABaa: 'bAA',
      aaBaBA: 'AAbAAb',
      bAAbAA: 'ABaBaa'
    });
    n = 5;
    m = 4;
    refRewriter = makeAppendRewriteRef(rewriteTable);
    compiledRewriter = makeAppendRewrite(rewriteTable);
    doTest = function(stack, chain0 = unity) {
      var chain, chainRef;
      //console.log "should stringify #{JSON.stringify stack}"
      //console.log "#{chainRef} != #{chain}"
      chainRef = refRewriter(chain0, stack.slice(0));
      chain = compiledRewriter(chain0, stack.slice(0));
      assert(chainRef.equals(chain), `${chain0} ++ ${JSON.stringify(stack)} -> ${chainRef} (ref) != ${chain}`);
    };
    walkChains = function(stack, depth, callback) {
      var a, b, i, j, ref, ref1;
      callback(stack);
      for (a = i = 1, ref = n; (1 <= ref ? i < ref : i > ref); a = 1 <= ref ? ++i : --i) {
        stack.push(['a', a]);
        callback(stack);
        for (b = j = 1, ref1 = m; (1 <= ref1 ? j < ref1 : j > ref1); b = 1 <= ref1 ? ++j : --j) {
          stack.push(['b', b]);
          callback(stack);
          if (depth > 0) {
            walkChains(stack, depth - 1, callback);
          }
          stack.pop();
        }
        stack.pop();
      }
    };
    
    //it "must produce same result as reference rewriter", ->
    //  walkChains [], 3, doTest
    //chain = ba^-2b, stack: [["a",1]], refValue: a^-1b^-1ab^-1, value: ba^2b^-1
    return doTest([["a", 1]], newNode('b', 1, newNode('a', -2, newNode('b', 1, unity))));
  });

  describe("extendLastPowerRewriteTable", function() {
    it("must extend positive powers", function() {
      var r, r1, r1_expected;
      r = new RewriteRuleset({
        'ab': 'Ba',
        'ba': 'B'
      });
      r1 = extendLastPowerRewriteTable(r.copy(), 'a', -3, 3);
      r1_expected = new RewriteRuleset({
        'ab': 'Ba',
        'ba': 'B',
        //new ruels:
        'baa': 'Ba',
        'baaa': 'Baa'
      });
      assert(!r.equals(r1), `Extended ruleset is not equal to original, ${JSON.stringify(r1)} != ${JSON.stringify(r)}`);
      return assert(r1.equals(r1_expected), `Extended ruleset is equal to expected, ${JSON.stringify(r1)} != ${JSON.stringify(r1_expected)}`);
    });
    return it("must extend negative powers", function() {
      var r, r1, r1_expected;
      r = new RewriteRuleset({
        'ab': 'Ba',
        'bA': 'B'
      });
      r1 = extendLastPowerRewriteTable(r.copy(), 'a', -3, 3);
      r1_expected = new RewriteRuleset({
        'ab': 'Ba',
        'bA': 'B',
        //new ruels:
        'bAA': 'BA',
        'bAAA': 'BAA'
      });
      assert(!r.equals(r1), `Extended ruleset is not equal to original, ${JSON.stringify(r1)} != ${JSON.stringify(r)}`);
      return assert(r1.equals(r1_expected), `Extended ruleset is equal to expected, ${JSON.stringify(r1)} != ${JSON.stringify(r1_expected)}`);
    });
  });

}).call(this);
