// Generated by CoffeeScript 2.7.0
(function() {
  var ChainMap, assert, newNode, unity;

  assert = require("assert");

  ({unity, newNode} = require("../src/core/vondyck_chain.coffee"));

  ({ChainMap} = require("../src/core/chain_map.coffee"));

  describe("ChainMap", function() {
    it("should support putting and removing empty chain", function() {
      var m;
      m = new ChainMap();
      m.put(unity, "empty");
      assert.equal(m.get(unity), "empty");
      assert.equal(m.count, 1);
      m.put(unity, "empty1");
      assert.equal(m.get(unity), "empty1");
      assert.equal(m.count, 1);
      assert(m.remove(unity));
      assert.equal(m.get(unity), null);
      return assert.equal(m.count, 0);
    });
    it("should support putting values wtih accumulation", function() {
      var a1, a1b1, b2, e, m;
      m = new ChainMap();
      e = unity;
      a1 = newNode("a", 1, unity);
      b2 = newNode("b", 2, unity);
      a1b1 = newNode("a", 1, newNode("b", 1, unity));
      //testing initial value for accumulation
      m.putAccumulate(a1b1, 1, (function(x, y) {
        return x + y;
      }), 10);
      assert.equal(m.get(a1b1), 11); //(initial is 10) + 1
      //for second value, existing is used.
      m.putAccumulate(a1b1, 1, (function(x, y) {
        return x + y;
      }), 10);
      return assert.equal(m.get(a1b1), 12); //(previous is 11) + 1
    });
    it("should support putting and removing non - empty chains", function() {
      var a1, a1b1, b2, e, m;
      m = new ChainMap();
      e = unity;
      a1 = newNode("a", 1, unity);
      b2 = newNode("b", 2, unity);
      a1b1 = newNode("a", 1, newNode("b", 1, unity));
      m.put(e, "e");
      m.put(a1, "a1");
      m.put(a1b1, "a1b1");
      m.put(b2, "b2");
      assert.equal(m.count, 4);
      assert.equal(m.get(e), "e");
      assert.equal(m.get(a1), "a1");
      assert.equal(m.get(b2), "b2");
      return assert.equal(m.get(a1b1), "a1b1");
    });
    it("should support copy", function() {
      var c1, c2, c3, c4, c5, cell, cells, i, index, j, k, l, len, len1, len2, len3, len4, m, m1, n, results;
      m = new ChainMap();
      c1 = unity;
      c2 = newNode('a', 2, unity);
      c3 = newNode('b', 3, unity);
      c4 = newNode('a', -1, c3);
      cells = [c1, c2, c3, c4];
      for (index = i = 0, len = cells.length; i < len; index = ++i) {
        cell = cells[index];
        m.put(cell, index);
      }
      m1 = m.copy();
//ensure that copy is right
      for (index = j = 0, len1 = cells.length; j < len1; index = ++j) {
        cell = cells[index];
        assert.equal(m1.get(cell), index);
      }
      assert.equal(m1.count, m.count);
//ensure that copy is independednt
      for (index = k = 0, len2 = cells.length; k < len2; index = ++k) {
        cell = cells[index];
        m.put(cell, index + 100);
      }
      for (index = l = 0, len3 = cells.length; l < len3; index = ++l) {
        cell = cells[index];
        assert.equal(m1.get(cell), index);
      }
      //ensure that copy is functional
      c5 = newNode('b', 3, c4);
      m1.put(c5, 100);
      assert.equal(m1.get(c5), 100);
      assert.equal(m.get(c5), null);
      results = [];
      for (index = n = 0, len4 = cells.length; n < len4; index = ++n) {
        cell = cells[index];
        results.push(assert.equal(m1.get(cell), index));
      }
      return results;
    });
    it("should remove cells without corrupting data", function() {
      var c1, c2, c3, c4, cell, cells, expected, i, index, j, k, l, len, len1, len2, len3, len4, len5, m, n, o, results;
      m = new ChainMap();
      c1 = unity;
      c2 = newNode('a', 2, unity);
      c3 = newNode('b', 3, unity);
      c4 = newNode('a', -1, c3);
      cells = [c1, c2, c3, c4];
      for (index = i = 0, len = cells.length; i < len; index = ++i) {
        cell = cells[index];
        m.put(cell, index);
      }
//check that data works fine
      for (index = j = 0, len1 = cells.length; j < len1; index = ++j) {
        cell = cells[index];
        assert.equal(m.get(cell), index);
      }
      //now delete something
      m.remove(c2);
      expected = [0, null, 2, 3];
      for (index = k = 0, len2 = cells.length; k < len2; index = ++k) {
        cell = cells[index];
        assert.equal(m.get(cell), expected[index]);
      }
      m.remove(c3);
      expected = [0, null, null, 3];
      for (index = l = 0, len3 = cells.length; l < len3; index = ++l) {
        cell = cells[index];
        assert.equal(m.get(cell), expected[index]);
      }
      m.remove(c4);
      expected = [0, null, null, null];
      for (index = n = 0, len4 = cells.length; n < len4; index = ++n) {
        cell = cells[index];
        assert.equal(m.get(cell), expected[index]);
      }
      m.remove(c1);
      expected = [null, null, null, null];
      results = [];
      for (index = o = 0, len5 = cells.length; o < len5; index = ++o) {
        cell = cells[index];
        results.push(assert.equal(m.get(cell), expected[index]));
      }
      return results;
    });
    return it("should support growing the table", function() {
      var a1, a2, a3, a4, a5, i, i1, i2, i3, i4, i5, initialTableSize, j, k, l, m, n, o, p, q, r, s;
      m = new ChainMap();
      initialTableSize = m.table.length;
      for (i1 = i = -5; i <= 5; i1 = ++i) {
        a1 = newNode('a', i1, unity);
        for (i2 = j = -5; j <= 5; i2 = ++j) {
          a2 = newNode('b', i2, a1);
          for (i3 = k = -5; k <= 5; i3 = ++k) {
            a3 = newNode('a', i3, a2);
            for (i4 = l = -5; l <= 5; i4 = ++l) {
              a4 = newNode('b', i4, a3);
              for (i5 = n = -5; n <= 5; i5 = ++n) {
                a5 = newNode('a', i5, a4);
                m.put(a5, true);
              }
            }
          }
        }
      }
      assert.equal(m.count, 11 ** 5);
      for (i1 = o = -5; o <= 5; i1 = ++o) {
        a1 = newNode('a', i1, unity);
        for (i2 = p = -5; p <= 5; i2 = ++p) {
          a2 = newNode('b', i2, a1);
          for (i3 = q = -5; q <= 5; i3 = ++q) {
            a3 = newNode('a', i3, a2);
            for (i4 = r = -5; r <= 5; i4 = ++r) {
              a4 = newNode('b', i4, a3);
              for (i5 = s = -5; s <= 5; i5 = ++s) {
                a5 = newNode('a', i5, a4);
                assert(m.get(a5));
              }
            }
          }
        }
      }
      assert(m.table.length > initialTableSize);
      //check that collision count is sane
      return it("must have sane collision count", function() {
        var cell, cellSizes;
        cellSizes = (function() {
          var len, ref, results, t;
          ref = m.table;
          results = [];
          for (t = 0, len = ref.length; t < len; t++) {
            cell = ref[t];
            results.push(cell.length);
          }
          return results;
        })();
        cellSizes.sort();
        return assert(cellSizes[cellSizes.length - 1] < 100);
      });
    });
  });

}).call(this);
