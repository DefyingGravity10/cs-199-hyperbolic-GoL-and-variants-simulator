// Generated by CoffeeScript 2.7.0
(function() {
  var M, assert;

  assert = require("assert");

  M = require("../src/core/matrix3");

  describe("approxEq", function() {
    it("must return true for equal matrices", function() {
      return assert.ok(M.approxEq([0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]));
    });
    return it("must return false for significantly in equal matrices", function() {
      var i, j, m1, m2, results;
      m1 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
      results = [];
      for (i = j = 0; j < 9; i = ++j) {
        m2 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        m2[i] = 1.0;
        results.push(assert.ok(!M.approxEq(m1, m2)));
      }
      return results;
    });
  });

  describe("eye", function() {
    return it("msut equal unit matrix", function() {
      var i, j, m;
      m = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 9; i = ++j) {
          results.push(0.0);
        }
        return results;
      })();
      for (i = j = 0; j < 3; i = ++j) {
        M.set(m, i, i, 1.0);
      }
      return assert.ok(M.approxEq(m, M.eye()));
    });
  });

  describe("mul", function() {
    it("must multiply eye to itself", function() {
      return assert.ok(M.approxEq(M.eye(), M.mul(M.eye(), M.eye())));
    });
    it("must return same non-eye matrix, if multiplied with eye", function() {
      var i, m;
      m = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 9; i = ++j) {
          results.push(i);
        }
        return results;
      })();
      assert.ok(M.approxEq(m, M.mul(m, M.eye())));
      return assert.ok(M.approxEq(m, M.mul(M.eye(), m)));
    });
    return it("must change non-eye matrix if squared", function() {
      var i, m;
      m = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 9; i = ++j) {
          results.push(i);
        }
        return results;
      })();
      return assert.ok(!M.approxEq(m, M.mul(m, m)));
    });
  });

  describe("rot", function() {
    it("must return eye if rotation angle is 0", function() {
      assert.ok(M.approxEq(M.eye(), M.rot(0, 1, 0.0)));
      assert.ok(M.approxEq(M.eye(), M.rot(0, 2, 0.0)));
      return assert.ok(M.approxEq(M.eye(), M.rot(1, 2, 0.0)));
    });
    return it("must return non-eye if rotation angle is not 0", function() {
      return assert.ok(!M.approxEq(M.eye(), M.rot(0, 1, 1.0)));
    });
  });

  describe("smul", function() {
    it("must return 0 if multiplied by 0", function() {
      return assert.ok(M.approxEq(M.zero(), M.smul(0.0, M.eye())));
    });
    return it("must return same if multiplied by 1", function() {
      return assert.ok(M.approxEq(M.eye(), M.smul(1.0, M.eye())));
    });
  });

  describe("translationMatrix", function() {
    it("must return unity for zero translation", function() {
      return assert.ok(M.approxEq(M.eye(), M.translationMatrix(0, 0)));
    });
    it("must return almost unity for very small translation", function() {
      return assert.ok(M.approxEq(M.eye(), M.translationMatrix(1e-5, 1e-5), 1e-4));
    });
    return it("must return matrix that correctly translates zero", function() {
      var T, expect, zero;
      T = M.translationMatrix(5, 6);
      zero = [0, 0, 1];
      expect = [5, 6, Math.sqrt(5 ** 2 + 6 ** 2 + 1)];
      return assert.ok(M.approxEqv(expect, M.mulv(T, zero)));
    });
  });

  describe("addScaledInplace", function() {
    it("must modify matrix inplace", function() {
      var expect, m, m1;
      m = M.eye();
      m1 = [1, 1, 1, 1, 1, 1, 1, 1, 1];
      M.addScaledInplace(m, m1, 1);
      expect = [2, 1, 1, 1, 2, 1, 1, 1, 2];
      return assert.ok(M.approxEqv(expect, m));
    });
    return it("must add with coefficient", function() {
      var expect, m, m1;
      m = M.eye();
      m1 = [1, 1, 1, 1, 1, 1, 1, 1, 1];
      M.addScaledInplace(m, m1, -2);
      expect = [-1, -2, -2, -2, -1, -2, -2, -2, -1];
      return assert.ok(M.approxEqv(expect, m));
    });
  });

  
  // describe "powerPade", ->
  //   it "must calculate powers of rotation matrices", ->
  //     m = M.rotationMatrix 0.6
  //     mpow = M.powerPade m, 1.3
  //     expect = M.rotationMatrix(0.6*1.3)
  //     assert.ok M.approxEqv mpow, expect, 1e-4

  //   it "must calculate zeroth power of rotation matrix", ->
  //     m = M.rotationMatrix 0.6
  //     mpow = M.powerPade m, 0.0
  //     assert.ok M.approxEqv mpow, M.eye(), 1e-4

  //   it "must calculate 0.5th power of hyperbolic translation matrices", ->
  //     m = M.translationMatrix 1.2, 4,5

  //     sqrt_m = M.powerPade m, 0.5

  //     sqrt_m2 = M.mul sqrt_m, sqrt_m

  //     console.dir m
  //     console.dir sqrt_m2
  //     assert.ok M.approxEqv sqrt_m2, m, 1e-4

  //     assert.ok M.approxEqv M.powerPade(m,0.0), M.eye(), 1e-4

  //   it "must calculate zeroth power of rotation matrix", ->
  //     m = M.rotationMatrix 0.6
  //     mpow = M.powerPade m, 0.0
  //     assert.ok M.approxEqv mpow, M.eye(), 1e-4

  //   it "must calculate powers of identity matrix", ->
  //     e = M.eye()

  //     assert.ok M.approxEqv e, M.powerPade(e, 1.0)
  //     assert.ok M.approxEqv e, M.powerPade(e, 0.5)
  //     assert.ok M.approxEqv e, M.powerPade(e, 1.5)        
  //     assert.ok M.approxEqv e, M.powerPade(e, 0.0)

  //   it "must calculate powers of zero matrix", ->
  //     z = M.smul 0, M.eye()
  //     assert.equal M.amplitude(z), 0

  //     assert.ok M.approxEqv z, M.powerPade(z, 1.0)
  //     assert.ok M.approxEqv z, M.powerPade(z, 0.5)
  //    assert.ok M.approxEqv z, M.powerPade(z, 0.0)
  describe("amplitude", function() {
    return it("must return maximal absolute value of matrix element", function() {
      var m;
      m = [1, 2, 3, 4, 5, 6, 7, 8, 9];
      assert.equal(M.amplitude(m), 9);
      m = [1, -2, 3, -4, 5, -6, 7, 8, -9];
      assert.equal(M.amplitude(m), 9);
      m = [-9, 2, 3, 4, 5, 6, 7, 8, 1];
      assert.equal(M.amplitude(m), 9);
      m = [9, -2, 3, -4, 5, -6, 7, 8, 1];
      assert.equal(M.amplitude(m), 9);
      m = [-3, 2, 3, 9, 5, 6, 7, 8, 1];
      assert.equal(M.amplitude(m), 9);
      m = [3, -2, 3, -9, 5, -6, 7, 8, 1];
      return assert.equal(M.amplitude(m), 9);
    });
  });

  describe("hyperbolicDecompose", function() {
    var almostEqual;
    almostEqual = function(x, y, message) {
      message = message != null ? message : `${x} not appox equal ${y}`;
      return assert.ok(Math.abs(x - y) < 1e-6, message);
    };
    it("must decompose identity to zero translation and zero rotation", function() {
      var dx, dy, rot;
      [rot, dx, dy] = M.hyperbolicDecompose(M.eye());
      almostEqual(rot, 0);
      almostEqual(dx, 0);
      return almostEqual(dy, 0);
    });
    return it("must decompose product of random nonzero translation and rotation", function() {
      var attempt, drot, dx, dx1, dy, dy1, j, m, message, results, rot, rot1;
      results = [];
      for (attempt = j = 0; j < 100; attempt = ++j) {
        dx = Math.random() * 10 - 5;
        dy = Math.random() * 10 - 5;
        rot = (Math.random() * 2 - 1) * Math.PI;
        m = M.mul(M.translationMatrix(dx, dy), M.rotationMatrix(rot));
        [rot1, dx1, dy1] = M.hyperbolicDecompose(m);
        message = `Incorrect decomposition. Code:
[dx,dy,rot] = [${dx}, ${dy}, ${rot}]
m = M.mul M.translationMatrix(dx,dy), M.rotationMatrix(rot)
rot1, dx1, dy1 = M.hyperbolicDecompose m
#rot1 = ${rot1}
#dx1 =  ${dx1}
#dy1 = ${dy1}`;
        almostEqual(dx, dx1, message);
        almostEqual(dy, dy1, message);
        drot = Math.abs(rot - rot1);
        results.push(assert.ok((drot < 1e-6) || Math.abs(drot - Math.PI * 2) < 1e-6, message));
      }
      return results;
    });
  });

  describe("powers", function() {
    return it("must return array of N first powers of a matrix", function() {
      var a, pows3;
      a = [1, 2, -1, 2, -1, 0, -3, 0, 0];
      pows3 = M.powers(a, 4);
      assert.equal(pows3.length, 4);
      assert.ok(M.approxEq(pows3[0], M.eye()));
      assert.ok(M.approxEq(pows3[1], a));
      assert.ok(M.approxEq(pows3[2], M.mul(a, a)));
      return assert.ok(M.approxEq(pows3[3], M.mul(a, M.mul(a, a))));
    });
  });

}).call(this);
