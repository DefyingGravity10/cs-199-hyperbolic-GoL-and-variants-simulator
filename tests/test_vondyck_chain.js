// Generated by CoffeeScript 2.7.0
(function() {
  var NodeA, NodeB, assert, newNode, parseChain, reverseShortlexLess, unity;

  assert = require("assert");

  ({unity, reverseShortlexLess, NodeA, NodeB, newNode, parseChain} = require("../src/core/vondyck_chain.coffee"));

  describe("chain.equals", function() {
    it("should return true for empty chains", function() {
      return assert(unity.equals(unity));
    });
    it("should return false for comparing non-empty with empty", function() {
      var a1, b1;
      a1 = new NodeA(1, unity);
      b1 = new NodeB(1, unity);
      assert(!unity.equals(a1));
      assert(!a1.equals(unity));
      assert(!unity.equals(b1));
      return assert(!b1.equals(unity));
    });
    it("should correctly compare chains of length 1", function() {
      var a1, a1_, a2, b1;
      a1 = new NodeA(1, unity);
      a1_ = new NodeA(1, unity);
      b1 = new NodeB(1, unity);
      a2 = new NodeA(2, unity);
      assert(a1.equals(a1));
      assert(a1.equals(a1_));
      assert(a1_.equals(a1));
      assert(!a1.equals(a2));
      assert(!a2.equals(a1));
      assert(!a1.equals(b1));
      return assert(!b1.equals(a1));
    });
    return it("should compare chains of length 2 and more", function() {
      var a1b1, a1b1a3, a1b2;
      a1b1 = new NodeA(1, new NodeB(1, unity));
      a1b2 = new NodeA(1, new NodeB(2, unity));
      a1b1a3 = new NodeA(1, new NodeB(1, new NodeA(3, unity)));
      assert(a1b1.equals(a1b1));
      assert(!a1b1.equals(a1b2));
      assert(!a1b1.equals(a1b1a3));
      return assert(!a1b1.equals(unity));
    });
  });

  describe("Node.hash", function() {
    var isNumber;
    isNumber = function(x) {
      return parseInt('' + x, 10) === x;
    };
    return it("must return different values for empty node, nodes of lenght 1", function() {
      var a1, a1b1, a2, b1, b2, c, c1, c2, chains, e, i, j, k, l, len, len1, results;
      e = unity;
      a1 = newNode('a', 1, unity);
      a1b1 = newNode('a', 1, newNode('b', 1, unity));
      a2 = newNode('a', 2, unity);
      b1 = newNode('b', 1, unity);
      b2 = newNode('b', 2, unity);
      chains = [e, a1, a2, b1, b2, a1b1];
      for (k = 0, len = chains.length; k < len; k++) {
        c = chains[k];
        assert(isNumber(c.hash()));
      }
      results = [];
      for (i = l = 0, len1 = chains.length; l < len1; i = ++l) {
        c1 = chains[i];
        results.push((function() {
          var len2, m, results1;
          results1 = [];
          for (j = m = 0, len2 = chains.length; m < len2; j = ++m) {
            c2 = chains[j];
            if (i !== j) {
              results1.push(assert.notEqual(c1.hash(), c2.hash(), `H ${c1} != H ${c2}`));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    });
  });

  describe("Chain.toStr", function() {
    return it("should convert node to text", function() {
      assert.equal('e', "" + unity);
      assert.equal('a', "" + (newNode('a', 1, unity)));
      assert.equal('A', "" + (newNode('a', -1, unity)));
      assert.equal('b', "" + (newNode('b', 1, unity)));
      assert.equal('B', "" + (newNode('b', -1, unity)));
      assert.equal('a^3', "" + (newNode('a', 3, unity)));
      return assert.equal('Aba^3', "" + (newNode('a', 3, newNode('b', 1, newNode('a', -1, unity)))));
    });
  });

  describe("parseChain", function() {
    return it("should convert node to text", function() {
      assert.ok(parseChain('e').equals(unity));
      assert.ok(parseChain('a').equals(newNode('a', 1, unity)));
      assert.ok(parseChain('A').equals(newNode('a', -1, unity)));
      assert.ok(parseChain('b').equals(newNode('b', 1, unity)));
      assert.ok(parseChain('B').equals(newNode('b', -1, unity)));
      assert.ok(parseChain('a^3').equals(newNode('a', 3, unity)));
      return assert.ok(parseChain('Aba^3').equals(newNode('a', 3, newNode('b', 1, newNode('a', -1, unity)))));
    });
  });

  describe("reverseShortlexLess", function() {
    var chain_B, chain_Baa, chain_a;
    chain_a = newNode('a', 1, unity);
    chain_B = newNode('b', -1, unity);
    chain_Baa = newNode('b', -1, newNode('a', 2, unity));
    it("should return false for equal chains", function() {
      assert(!reverseShortlexLess(unity, unity));
      assert(!reverseShortlexLess(chain_a, chain_a));
      assert(!reverseShortlexLess(chain_B, chain_B));
      return assert(!reverseShortlexLess(chain_Baa, chain_Baa));
    });
    it("should compare chains of different len", function() {
      assert(reverseShortlexLess(unity, chain_a));
      assert(reverseShortlexLess(unity, chain_B));
      assert(reverseShortlexLess(unity, chain_Baa));
      assert(!reverseShortlexLess(chain_a, unity));
      assert(!reverseShortlexLess(chain_B, unity));
      assert(!reverseShortlexLess(chain_Baa, unity));
      assert(reverseShortlexLess(chain_a, chain_Baa));
      return assert(!reverseShortlexLess(chain_Baa, chain_a));
    });
    return it("should compare chains of same len", function() {
      assert(reverseShortlexLess(chain_a, chain_B));
      return assert(!reverseShortlexLess(chain_B, chain_a));
    });
  });

}).call(this);
