// Generated by CoffeeScript 2.7.0
(function() {
  var M, assert, decomposeToTranslations, decomposeToTranslationsAggresively;

  assert = require("assert");

  M = require("../src/core/matrix3");

  ({decomposeToTranslations, decomposeToTranslationsAggresively} = require("../src/core/decompose_to_translations"));

  describe("decomposeToTranslations", function() {
    it("must decompose unity matrix to itself", function() {
      var t1, t2;
      [t1, t2] = decomposeToTranslations(M.eye());
      //console.log "Found:"
      //console.dir t1
      //console.dir t2
      assert.ok(t1 != null);
      assert.ok(M.approxEq(t1, M.eye()));
      assert.ok(t2 != null);
      return assert.ok(M.approxEq(t2, M.eye()));
    });
    it("must decompose translation matrix to itself and unity", function() {
      var t, t1, t2;
      t = M.translationMatrix(2, 3);
      [t1, t2] = decomposeToTranslations(t);
      //console.log "Found:"
      //console.dir t1
      //console.dir t2
      assert.ok(t1 != null);
      assert.ok(M.approxEq(t1, M.eye()));
      assert.ok(t2 != null);
      return assert.ok(M.approxEq(t2, t));
    });
    it("must not decompose pure rotation matrix", function() {
      var t, t1, t2;
      t = M.rotationMatrix(0.4);
      [t1, t2] = decomposeToTranslations(t);
      //console.log "Found:"
      //console.dir t1
      //console.dir t2
      assert.ok(t1 === null);
      return assert.ok(t2 === null);
    });
    it("must decompose some matrix", function() {
      var t, t1, t2, tRestored;
      t = M.mul(M.rotationMatrix(0.3), M.translationMatrix(2, 3));
      [t1, t2] = decomposeToTranslations(t);
      assert.ok(t1 != null);
      assert.ok(t2 != null);
      tRestored = M.mul(M.hyperbolicInv(t1), M.mul(t2, t1));
      return assert.ok(M.approxEq(tRestored, t, 1e-5));
    });
    return it("must decompose some hard matrix", function() {
      var t, t1, t2, tRestored;
      t = [5.58512230547673, -4.886985710846093, 7.3536535480771485, 12.220681374785933, -7.783877858381329, 14.454542807651823, 13.399203126722638, -9.136267501130483, 16.248385405429882];
      [t1, t2] = decomposeToTranslations(t);
      assert.ok(t1 != null);
      assert.ok(t2 != null);
      tRestored = M.mul(M.hyperbolicInv(t1), M.mul(t2, t1));
      return assert.ok(M.approxEq(tRestored, t, 1e-4));
    });
  });

  // describe "decomposeToTranslationsAggresively", ->
//   it "must decompose high-amplitude matrix", ->

  //     #Obtained from practice. decmposition possible, but hard
//     m = [5.58512230547673, -4.886985710846093, 7.3536535480771485,
//          12.220681374785933, -7.783877858381329, 14.454542807651823,
//          13.399203126722638, -9.136267501130483, 16.248385405429882]

  //     [t1,t2] = decomposeToTranslationsAggresively m
//     assert.ok t1?
//     assert.ok t2?

  //     tRestored = M.mul M.hyperbolicInv(t1), M.mul t2, t1
//     console.log "restored"
//     console.dir tRestored
//     console.log "original"
//     console.dir t

  //     assert.ok M.approxEq tRestored, t, 1e-5

}).call(this);
