// Generated by CoffeeScript 2.7.0
(function() {
  var ChainMap, RegularTiling, allClusters, assert, exportField, importField, newNode, parseFieldData, randomFillFixedNum, randomStateGenerator, stringifyFieldData, unity;

  assert = require("assert");

  ({allClusters, exportField, importField, parseFieldData, randomStateGenerator, stringifyFieldData, randomFillFixedNum} = require("../src/core/field"));

  ({unity, newNode} = require("../src/core/vondyck_chain.coffee"));

  ({ChainMap} = require("../src/core/chain_map.coffee"));

  ({RegularTiling} = require("../src/core/regular_tiling.coffee"));

  describe("allClusters", function() {
    var M, N, tiling;
    //prepare data: rewriting ruleset for group 5;4

    [N, M] = [5, 4];
    tiling = new RegularTiling(N, M);
    it("should give one cell, if only one central cell present", function() {
      var cells, clusters;
      cells = new ChainMap();
      cells.put(unity, 1);
      clusters = allClusters(cells, tiling);
      assert.equal(clusters.length, 1);
      return assert.deepEqual(clusters, [[unity]]); //one cluster of 1 cell
    });
    return it("should give one cell, if only one central cell present", function() {
      var c, cells, clusters;
      cells = new ChainMap();
      c = tiling.toCell(tiling.parse("Ab^2a^2"));
      cells.put(c, 1);
      clusters = allClusters(cells, tiling);
      assert.equal(clusters.length, 1);
      assert.deepEqual(clusters[0].length, 1);
      return assert(clusters[0][0].equals(c));
    });
  });

  describe("exportField", function() {
    it("must export empty field", function() {
      var f, tree;
      f = new ChainMap();
      tree = exportField(f);
      return assert.deepEqual(tree, {});
    });
    it("must export field with only root cell", function() {
      var f, tree;
      f = new ChainMap();
      f.put(unity, 1);
      tree = exportField(f);
      return assert.deepEqual(tree, {
        v: 1
      });
    });
    return it("must export field with 1 non-root cell", function() {
      var chain, f, tree;
      f = new ChainMap();
      //ab^3a^2
      chain = newNode('a', 2, newNode('b', 3, newNode('a', 1, unity)));
      f.put(chain, "value");
      tree = exportField(f);
      return assert.deepEqual(tree, {
        cs: [
          {
            a: 1,
            cs: [
              {
                b: 3,
                cs: [
                  {
                    a: 2,
                    v: "value"
                  }
                ]
              }
            ]
          }
        ]
      });
    });
  });

  describe("randomStateGenerator", function() {
    var makeStates;
    makeStates = function(nStates, nValues) {
      var _, gen, i, ref, results;
      gen = randomStateGenerator(nStates);
      results = [];
      for (_ = i = 0, ref = nValues; (0 <= ref ? i < ref : i > ref); _ = 0 <= ref ? ++i : --i) {
        results.push(gen());
      }
      return results;
    };
    return it("must produce random values in required range", function() {
      var counts, i, len, states, x;
      states = makeStates(5, 1000);
      assert.equal(states.length, 1000);
      //should for sure contain at least one of values 1,2,3,4
      //should not contain 0
      //should not contain >=5
      counts = [0, 0, 0, 0, 0];
      for (i = 0, len = states.length; i < len; i++) {
        x = states[i];
        counts[x] += 1;
      }
      assert.equal(counts[0], 0);
      assert(counts[1] > 0);
      assert(counts[2] > 0);
      assert(counts[3] > 0);
      assert(counts[4] > 0);
      return assert.equal(counts[1] + counts[2] + counts[3] + counts[4], 1000);
    });
  });

  describe("stringifyFieldData", function() {
    it("must stringify empty", function() {
      var f;
      f = {};
      return assert.equal(stringifyFieldData(f), "");
    });
    it("must cell at origin", function() {
      var f;
      f = {
        v: 1
      };
      return assert.equal(stringifyFieldData(f), "|1");
    });
    return it("must other cells", function() {
      var f;
      f = {
        v: 1,
        cs: [
          {
            a: 1,
            v: 2
          },
          {
            a: -2,
            v: 3
          }
        ]
      };
      return assert.equal(stringifyFieldData(f), "|1(a|2)(A2|3)");
    });
  });

  describe("parseFieldData", function() {
    it("must parse empty string", function() {
      var f;
      f = parseFieldData("");
      return assert.deepEqual(f, {});
    });
    it("must parse cell at origin", function() {
      var f;
      f = parseFieldData("|1");
      return assert.deepEqual(f, {
        v: 1
      });
    });
    return it("must parse non-trivial", function() {
      var f, tree;
      tree = {
        cs: [
          {
            a: 1,
            cs: [
              {
                b: -3,
                cs: [
                  {
                    a: 2,
                    v: 1
                  }
                ]
              }
            ]
          }
        ]
      };
      f = parseFieldData("(a(B3(a2|1)))");
      return assert.deepEqual(f, tree);
    });
  });

  describe("importField", function() {
    it("must import empty field correctly", function() {
      var f;
      f = importField({});
      return assert.equal(f.count, 0);
    });
    it("must import root cell correctly", function() {
      var f;
      f = importField({
        v: 1
      });
      assert.equal(f.count, 1);
      return assert.equal(f.get(unity), 1);
    });
    it("must import 1 non-root cell correctly", function() {
      var chain, f, tree;
      tree = {
        cs: [
          {
            a: 1,
            cs: [
              {
                b: 3,
                cs: [
                  {
                    a: 2,
                    v: "value"
                  }
                ]
              }
            ]
          }
        ]
      };
      //ab^3a^2
      chain = newNode('a', 2, newNode('b', 3, newNode('a', 1, unity)));
      f = importField(tree);
      assert.equal(f.count, 1);
      return assert.equal(f.get(chain), 'value');
    });
    it("must import some nontrivial exported field", function() {
      var chain1, chain2, f, f1;
      f = new ChainMap();
      //ab^3a^2
      chain1 = newNode('a', 2, newNode('b', 3, newNode('a', 1, unity)));
      //a^-1b^3a^2
      chain2 = newNode('a', -1, newNode('b', 3, newNode('a', 1, unity)));
      f.put(unity, "value0");
      f.put(chain1, "value1");
      f.put(chain2, "value2");
      f1 = importField(exportField(f));
      assert.equal(f1.count, 3);
      assert.equal(f1.get(unity), 'value0');
      assert.equal(f1.get(chain1), 'value1');
      return assert.equal(f1.get(chain2), 'value2');
    });
    return it("must support preprocessing imported data", function() {
      var chain1, chain2, f, f1, preprocessor;
      f = new ChainMap();
      //ab^3a^2
      chain1 = newNode('a', 2, newNode('b', 3, newNode('a', 1, unity)));
      //a^-1b^3a^2
      chain2 = newNode('a', -1, newNode('b', 3, newNode('a', 1, unity)));
      f.put(unity, "value0");
      f.put(chain1, "value1");
      f.put(chain2, "value2");
      //Preprocessor simply appends b^2 to the chain
      preprocessor = function(chain) {
        return newNode('b', 2, chain);
      };
      f1 = importField(exportField(f), null, preprocessor);
      assert.equal(f1.count, 3);
      assert.equal('value0', f1.get(newNode('b', 2, unity)), assert.equal('value1', f1.get(newNode('b', 2, newNode('a', 2, newNode('b', 3, newNode('a', 1, unity)))))));
      return assert.equal('value2', f1.get(newNode('b', 2, newNode('a', -1, newNode('b', 3, newNode('a', 1, unity))))));
    });
  });

  describe("randomFillFixedNum", function() {
    return it("must fill some reasonable number of cells", function() {
      var M, N, field, nCells, tiling;
      [N, M] = [5, 4];
      tiling = new RegularTiling(N, M);
      field = new ChainMap();
      nCells = 10000;
      randomFillFixedNum(field, 0.4, unity, 10000, tiling);
      //not guaranteed, but chances of failure are small.
      assert.ok(field.count > 0.4 * nCells * 0.7);
      return assert.ok(field.count < 0.4 * nCells * 1.3);
    });
  });

}).call(this);
