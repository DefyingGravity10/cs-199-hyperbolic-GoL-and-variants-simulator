// Generated by CoffeeScript 2.7.0
(function() {
  var M, RegularTiling, VonDyck, assert;

  assert = require("assert");

  M = require("../src/core/matrix3.coffee");

  ({VonDyck} = require("../src/core/vondyck.coffee"));

  ({RegularTiling} = require("../src/core/regular_tiling.coffee"));

  // Knuth-Bendix solver for vonDyck groups, cleaned up API

  describe("New API", function() {
    return it("Must work", function() {
      var arr, group, u, x, x1, x11, x12, x2, x3;
      group = new VonDyck(3, 4);
      // aaa = bbbb = abab = 1
      assert.equal(group.n, 3);
      assert.equal(group.m, 4);
      assert.equal(group.k, 2);
      assert.equal(group.type(), "spheric"); //octahedron
      u = group.unity;
      //Parsing and stringification
      x1 = u.a(1).b(-2).a(3);
      assert.equal(x1.toString(), "aB^2a^3");
      x11 = group.parse("aB^2a^3");
      assert.ok(x1.equals(x11));
      x12 = group.parse("A^3b2^A");
      assert.ok(!x1.equals(x12));
      assert.ok(u.equals(group.parse('')));
      assert.ok(u.equals(group.parse('e')));
      //Array conversion
      arr = u.a(2).b(-2).a(3).asStack();
      assert.deepEqual(arr, [['a', 3], ['b', -2], ['a', 2]]);
      
      //Normalization
      group.solve();
      x = group.appendRewrite(group.unity, [['a', 2], ['b', 3]]);
      x1 = group.appendRewrite(group.unity, [['a', 2], ['b', 3]]);
      x2 = group.appendRewrite(group.unity, [['a', 2], ['a', 1], ['b', 1], ['a', 1], ['b', 1], ['b', -1]]);
      x3 = group.rewrite(u.b(3).a(2));
      assert.ok(x.equals(x1));
      assert.ok(x.equals(x2));
      return assert.ok(x.equals(x3));
    });
  });

  describe("New VonDyck", function() {
    return it("must detect group type", function() {
      assert.equal((new VonDyck(3, 3)).type(), "spheric");
      assert.equal((new VonDyck(3, 4)).type(), "spheric");
      assert.equal((new VonDyck(3, 5)).type(), "spheric");
      assert.equal((new VonDyck(3, 6)).type(), "euclidean"); //triangualr tiling
      assert.equal((new VonDyck(3, 7)).type(), "hyperbolic"); //triangualr tiling
      assert.equal((new VonDyck(4, 3)).type(), "spheric");
      assert.equal((new VonDyck(4, 4)).type(), "euclidean");
      assert.equal((new VonDyck(4, 5)).type(), "hyperbolic");
      assert.equal((new VonDyck(5, 3)).type(), "spheric");
      return assert.equal((new VonDyck(5, 4)).type(), "hyperbolic");
    });
  });

  describe("VonDyck.repr", function() {
    var group;
    group = new VonDyck(4, 5);
    return it("should return unity matrix for empty node", function() {
      assert(M.approxEq(group.repr(group.unity), M.eye()));
      assert(!M.approxEq(group.repr(group.parse("a")), M.eye()));
      assert(!M.approxEq(group.repr(group.parse("b")), M.eye()));
      return assert(M.approxEq(group.repr(group.parse("abab")), M.eye()));
    });
  });

  describe("VonDyck.inverse", function() {
    var group, m, n, unity;
    n = 5;
    m = 4;
    group = new VonDyck(n, m);
    group.solve();
    unity = group.unity;
    it("should inverse unity", function() {
      return assert(unity.equals(group.inverse(unity)));
    });
    it("should inverse simple 1-element values", function() {
      var c, ic;
      c = group.parse("a");
      ic = group.parse("A");
      return assert(group.inverse(c).equals(ic));
    });
    return it("should return same chain after double rewrite", function() {
      var c, ic, iic;
      c = group.rewrite(group.parse("ba^2B^2a^3b"));
      ic = group.inverse(c);
      iic = group.inverse(ic);
      assert(!c.equals(ic));
      return assert(c.equals(iic));
    });
  });

  describe("VonDyck.appendInverse", function() {
    var group, m, n, unity;
    n = 5;
    m = 4;
    group = new VonDyck(n, m);
    group.solve();
    unity = group.unity;
    it("unity * unity^-1 = unity", function() {
      return assert(unity.equals(group.appendInverse(unity, unity)));
    });
    it("For simple 1-element values, x * (x^-1) = unity", function() {
      var c;
      c = group.parse("a");
      return assert(group.appendInverse(c, c).equals(unity));
    });
    return it("For non-simple chain, x*(x^-1) = unitu", function() {
      var c;
      c = group.rewrite(group.parse("ba^2B^2a^3b"));
      assert(!c.equals(unity));
      return assert(group.appendInverse(c, c).equals(unity));
    });
  });

  describe("VonDyck.append", function() {
    var group, m, n, unity;
    n = 5;
    m = 4;
    group = new VonDyck(n, m);
    group.solve();
    unity = group.unity;
    it("choud append unity", function() {
      var c;
      assert(unity.equals(group.append(unity, unity)));
      c = group.parse('a');
      assert(c.equals(group.append(c, unity)));
      return assert(c.equals(group.append(unity, c)));
    });
    return it("shouls append inverse and return unity", function() {
      var c, ic;
      c = group.rewrite(unity.appendStack([['b', 1], ['a', 2], ['b', -2], ['a', 3], ['b', 1]]));
      ic = group.inverse(c);
      assert(unity.equals(group.append(c, ic)));
      return assert(unity.equals(group.append(ic, c)));
    });
  });

  describe("RegularTiling", function() {
    return it("must support cell coordinate normalization", function() {
      var checkTrimmingIsUnique, tiling, x;
      tiling = new RegularTiling(3, 4);
      //last A elimination
      x = tiling.parse("bab"); //eliminated to 1 by adding a: bab+a = baba = e
      assert.ok(tiling.toCell(x).equals(tiling.unity));
      checkTrimmingIsUnique = function(chain) {
        var aPower, chain1, k, ref, ref1, results, trimmedChain;
        trimmedChain = tiling.toCell(chain);
        results = [];
        for (aPower = k = ref = -tiling.n, ref1 = tiling.n; (ref <= ref1 ? k <= ref1 : k >= ref1); aPower = ref <= ref1 ? ++k : --k) {
          if (aPower === 0) {
            continue;
          }
          chain1 = chain.a(aPower);
          if (!tiling.toCell(chain1).equals(trimmedChain)) {
            throw new Error(`Chain ${chain1} trimmed returns ${tiling.toCell(chain1)} != ${trimmedChain}`);
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      checkTrimmingIsUnique(tiling.parse("e"));
      checkTrimmingIsUnique(tiling.parse("a"));
      checkTrimmingIsUnique(tiling.parse("A"));
      checkTrimmingIsUnique(tiling.parse("b"));
      checkTrimmingIsUnique(tiling.parse("B"));
      checkTrimmingIsUnique(tiling.parse("ba^2ba^2B"));
      return checkTrimmingIsUnique(tiling.parse("Ba^3bab^2"));
    });
  });

  describe("RegularTiling.moore", function() {
    var cells, m, n, tiling, unity;
    //prepare data: rewriting ruleset for group 5;4

    [n, m] = [5, 4];
    tiling = new RegularTiling(n, m);
    unity = tiling.unity;
    cells = [];
    cells.push(unity);
    cells.push(tiling.toCell(tiling.rewrite(tiling.parse("b"))));
    cells.push(tiling.toCell(tiling.rewrite(tiling.parse("b^2"))));
    cells.push(tiling.toCell(tiling.rewrite(tiling.parse("ab^2"))));
    it("must return expected number of cells different from origin", function() {
      var cell, i, j, k, l, len, len1, len2, nei, nei1, neighbors, o;
      for (k = 0, len = cells.length; k < len; k++) {
        cell = cells[k];
        neighbors = tiling.moore(cell);
        assert.equal(neighbors.length, n * (m - 2));
        for (i = l = 0, len1 = neighbors.length; l < len1; i = ++l) {
          nei = neighbors[i];
          assert(!cell.equals(nei));
          for (j = o = 0, len2 = neighbors.length; o < len2; j = ++o) {
            nei1 = neighbors[j];
            if (i !== j) {
              assert(!nei.equals(nei1), `neighbors ${i}=${nei1} and ${j}=${nei1} must be not equal`);
            }
          }
        }
      }
    });
    return it("must be true that one of neighbor's neighbor is self", function() {
      var cell, foundCell, k, l, len, len1, len2, nei, nei1, o, ref, ref1;
      for (k = 0, len = cells.length; k < len; k++) {
        cell = cells[k];
        ref = tiling.moore(cell);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          nei = ref[l];
          foundCell = 0;
          ref1 = tiling.moore(nei);
          for (o = 0, len2 = ref1.length; o < len2; o++) {
            nei1 = ref1[o];
            if (nei1.equals(cell)) {
              foundCell += 1;
            }
          }
          assert.equal(foundCell, 1, `Exactly 1 of the ${nei}'s neighbors must be original chain: ${cell}, but ${foundCell} found`);
        }
      }
    });
  });

  describe("RegularTiling.forFarNeighborhood", function() {
    var chain1, norm, tiling, unity;
    tiling = new RegularTiling(5, 4);
    unity = tiling.unity;
    //Make normalized node from array
    norm = function(arr) {
      return tiling.toCell(tiling.appendRewrite(unity, arr));
    };
    chain1 = norm([['b', 1], ['a', 2]]);
    assert(!chain1.equals(unity));
    it("should start enumeration from the original cell", function() {
      tiling.forFarNeighborhood(unity, function(node, radius) {
        assert.equal(radius, 0, "Must start from 0 radius");
        assert.ok(node.equals(unity), "Must start from the center");
        //Stop after the first.
        return false;
      });
      return tiling.forFarNeighborhood(chain1, function(node, radius) {
        assert.equal(radius, 0, "Must start from 0 radius");
        assert.ok(node.equals(chain1), "Must start from the center");
        //Stop after the first.
        return false;
      });
    });
    return it("should produce all different cells in strictly increasing order", function() {
      var lastLevel, visitedNodes;
      visitedNodes = [];
      lastLevel = 0;
      tiling.forFarNeighborhood(chain1, function(node, level) {
        var k, len, visited;
        assert.ok((level === lastLevel) || (level === lastLevel + 1));
        for (k = 0, len = visitedNodes.length; k < len; k++) {
          visited = visitedNodes[k];
          assert.ok(!visited.equals(node));
        }
        visitedNodes.push(node);
        lastLevel = level;
        return level < 6;
      });
      assert.equal(lastLevel, 6);
      return assert.ok(visitedNodes.length > 10);
    });
  });

  describe("RegularTiling.mooreNeighborhood", function() {
    var cells, m, n, rewriteChain, tiling, unity;
    //prepare data: rewriting ruleset for group 5;4

    [n, m] = [5, 4];
    tiling = new RegularTiling(n, m);
    unity = tiling.unity;
    rewriteChain = function(arr) {
      return tiling.appendRewrite(unity, arr.slice(0));
    };
    cells = [];
    cells.push(unity);
    cells.push(tiling.toCell(rewriteChain([['b', 1]])));
    cells.push(tiling.toCell(rewriteChain([['b', 2]])));
    cells.push(tiling.toCell(rewriteChain([['b', 2], ['a', 1]])));
    it("must return expected number of cells different from origin", function() {
      var cell, i, j, k, l, len, len1, len2, nei, nei1, neighbors, o;
      for (k = 0, len = cells.length; k < len; k++) {
        cell = cells[k];
        neighbors = tiling.moore(cell);
        assert.equal(neighbors.length, n * (m - 2));
        for (i = l = 0, len1 = neighbors.length; l < len1; i = ++l) {
          nei = neighbors[i];
          assert(!cell.equals(nei));
          for (j = o = 0, len2 = neighbors.length; o < len2; j = ++o) {
            nei1 = neighbors[j];
            if (i !== j) {
              assert(!nei.equals(nei1), `neighbors ${i}=${nei1} and ${j}=${nei1} must be not equal`);
            }
          }
        }
      }
    });
    return it("must be true that one of neighbor's neighbor is self", function() {
      var cell, foundCell, k, l, len, len1, len2, nei, nei1, o, ref, ref1;
      for (k = 0, len = cells.length; k < len; k++) {
        cell = cells[k];
        ref = tiling.moore(cell);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          nei = ref[l];
          foundCell = 0;
          ref1 = tiling.moore(nei);
          for (o = 0, len2 = ref1.length; o < len2; o++) {
            nei1 = ref1[o];
            if (nei1.equals(cell)) {
              foundCell += 1;
            }
          }
          assert.equal(foundCell, 1, `Exactly 1 of the ${nei}'s neighbors must be original chain: ${cell}, but ${foundCell} found`);
        }
      }
    });
  });

}).call(this);
